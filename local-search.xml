<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于antd的select的value</title>
    <link href="/2021/09/15/%E5%85%B3%E4%BA%8Eantd%E7%9A%84select%E7%9A%84value/"/>
    <url>/2021/09/15/%E5%85%B3%E4%BA%8Eantd%E7%9A%84select%E7%9A%84value/</url>
    
    <content type="html"><![CDATA[<p>今天在使用antd的select组件时候发现直接获取dom取value值为undefined，想要获取value值只能通过onchange函数传递value<br><img src="https://cdn.jsdelivr.net/gh/Zeij/CDN/img/QQ%E5%9B%BE%E7%89%8720210915210416.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Node笔记</title>
    <link href="/2021/09/13/Node%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/09/13/Node%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="module-exports和require"><a href="#module-exports和require" class="headerlink" title="module.exports和require"></a>module.exports和require</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> =xxx;<span class="hljs-comment">//暴露模块</span><br><span class="hljs-keyword">const</span> xxx=require(<span class="hljs-string">&#x27;./xxx&#x27;</span>)<span class="hljs-comment">//引入模块</span><br></code></pre></td></tr></table></figure><h2 id="rs核心模块"><a href="#rs核心模块" class="headerlink" title="rs核心模块"></a>rs核心模块</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs=<span class="hljs-built_in">require</span>.(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>fs.readFile(<span class="hljs-string">&#x27;xxx.txt&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-built_in">console</span>.log(err);<br>    <span class="hljs-built_in">console</span>.log(data.toString())<span class="hljs-comment">//data为buffer数据</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="path核心模块"><a href="#path核心模块" class="headerlink" title="path核心模块"></a>path核心模块</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path=<span class="hljs-built_in">require</span>.(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">let</span> a=<span class="hljs-string">&#x27;www.baidu.com&#x27;</span>,b=<span class="hljs-string">&#x27;docs&#x27;</span>,c=<span class="hljs-string">&#x27;22&#x27;</span>;<br><span class="hljs-keyword">let</span> address=path.join(a,b,c);<br><span class="hljs-built_in">console</span>.log(address)<span class="hljs-comment">//www.baidu.com\docs\22</span><br></code></pre></td></tr></table></figure><h3 id="http核心模块"><a href="#http核心模块" class="headerlink" title="http核心模块"></a>http核心模块</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> server=http.createServe(<span class="hljs-function">(<span class="hljs-params">req,res</span>)=&gt;</span>&#123;<br>    res.end(<span class="hljs-string">&#x27;hello world&#x27;</span>;<br>&#125;);<br>server.listen(<span class="hljs-number">3000.</span> ()=&gt;&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Server is running`</span>);<br>&#125;)<br>)<br></code></pre></td></tr></table></figure><h2 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h2><p>nodemon启动可以实时刷新服务器</p><h2 id="Koa框架"><a href="#Koa框架" class="headerlink" title="Koa框架"></a>Koa框架</h2><p>更便捷搭建Web服务器</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cnpm install -save Koa <span class="hljs-regexp">//</span>安装Koa框架<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Koa=<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<span class="hljs-comment">//引入Koa框架</span><br><span class="hljs-keyword">const</span> app=<span class="hljs-keyword">new</span> Koa();<span class="hljs-comment">//创建应用</span><br>app.use(<span class="hljs-keyword">async</span> ctx=&gt;&#123;<br>    ctx.body=<span class="hljs-string">&#x27;hello koa&#x27;</span>;<span class="hljs-comment">//响应内容</span><br>&#125;)<br>app.listen(<span class="hljs-number">3000</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;server is running&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="路由和静态文件"><a href="#路由和静态文件" class="headerlink" title="路由和静态文件"></a>路由和静态文件</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs processing">cnpm install -<span class="hljs-built_in">save</span> koa-router<br>cnpm install -<span class="hljs-built_in">save</span> koa-<span class="hljs-keyword">static</span><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const Koa=require(<span class="hljs-string">&#x27;koa&#x27;</span>);//引入Koa框架<br>const router =require(<span class="hljs-string">&#x27;koa-router)();//koa-router是个函数，引入并执行</span><br><span class="hljs-string">const static=require(&#x27;</span>koa-static<span class="hljs-string">&#x27;);</span><br><span class="hljs-string">const app=new Koa();//创建应用</span><br><span class="hljs-string"></span><br><span class="hljs-string">app.use(static(__dirname+&#x27;</span>/<span class="hljs-built_in">public</span><span class="hljs-string">&#x27;));</span><br><span class="hljs-string">&lt;!-- app.use(async ctx=&gt;&#123;</span><br><span class="hljs-string">    ctx.body=&#x27;</span>hello koa<span class="hljs-string">&#x27;;//响应内容</span><br><span class="hljs-string">&#125;) --&gt;</span><br><span class="hljs-string">router.get(&#x27;</span>/<span class="hljs-string">&#x27;，async(ctx)=&gt;&#123;</span><br><span class="hljs-string">    ctx.body=`&lt;h1&gt;标题&lt;/h1&gt;</span><br><span class="hljs-string">    &lt;p&gt;文本内容&lt;/p&gt;</span><br><span class="hljs-string">    &lt;img scr=&#x27;</span>./images/logo.jpg<span class="hljs-string">&#x27;&gt;//引入图片需要把图片放入静态文件目录</span><br><span class="hljs-string">    `;</span><br><span class="hljs-string">&#125;)</span><br><span class="hljs-string">router.get(&#x27;</span>/video<span class="hljs-string">&#x27;,async ctx=&gt;&#123;</span><br><span class="hljs-string">    ctx.body=&#x27;</span>video pag<span class="hljs-string">e&#x27;;</span><br><span class="hljs-string">&#125;)</span><br><span class="hljs-string">app.use(router.routes());//在koa项目中引入router</span><br><span class="hljs-string">app.listen(3000,()=&gt;&#123;</span><br><span class="hljs-string">    console.log(&#x27;</span><span class="hljs-keyword">server</span> <span class="hljs-keyword">is</span> running<span class="hljs-string">&#x27;);</span><br><span class="hljs-string">&#125;)</span><br></code></pre></td></tr></table></figure><h2 id="Nunjucks模版"><a href="#Nunjucks模版" class="headerlink" title="Nunjucks模版"></a>Nunjucks模版</h2><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs q">cnpm install -sava koa-<span class="hljs-built_in">views</span><span class="hljs-comment">//通过其指定模版</span><br>cnpm install -<span class="hljs-built_in">save</span> nunjucks<br></code></pre></td></tr></table></figure><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> Koa=<span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<span class="hljs-comment">//引入Koa框架</span><br><span class="hljs-keyword">const</span> views=<span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;koa-views&#x27;</span>);<br><span class="hljs-keyword">const</span> nunjucks=<span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;nunjucks&#x27;</span>);<br><span class="hljs-keyword">const</span> app=<span class="hljs-keyword">new</span> Koa();<br>app.<span class="hljs-keyword">use</span>(views(__dirname+<span class="hljs-string">&#x27;/views&#x27;</span>)),&#123;<br>    map:&#123;html:<span class="hljs-string">&#x27;nunjucks&#x27;</span>&#125;<br>&#125;;<br>app.<span class="hljs-keyword">use</span>(asyc(ctx)=&gt;&#123;<br>    await ctx.render(<span class="hljs-string">&#x27;index&#x27;</span>)<br>&#125;)<br>app.listen(<span class="hljs-number">3000</span>,()=&gt;&#123;<br>    console.log(<span class="hljs-string">&#x27;server is running&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React笔记</title>
    <link href="/2021/09/13/React%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/09/13/React%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="四大文件"><a href="#四大文件" class="headerlink" title="四大文件"></a>四大文件</h2><ul><li>React.js引入核心库</li><li>React-dom.js 用于支持React操作Dom</li><li>babel.js用于将jsx转为js<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">JSX语法规则虚拟Dom不要单引号（不再是文本) 标签中引入JS表达式要用&#123;&#125;，样式的类名指定不用<span class="hljs-keyword">class</span>而用<span class="hljs-symbol">className</span>，内联样式要用<span class="hljs-symbol">style</span>=&#123;&#123;key:value&#125;&#125;的形式写，多单词记得驼峰。虚拟DOM必须只有一个根标签，标签必须闭合    <br>虚拟Dom渲染ReactDOM.render<br><br>虚拟Dom为Object对象，属性相比真实Dom较少<br><br>XML早期用于存储和传输数据，后改用JSON<br><br>组件自定义方法用箭头函数和赋值语句<br></code></pre></td></tr></table></figure><h2 id="props属性"><a href="#props属性" class="headerlink" title="props属性"></a>props属性</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;<br>    constructor(props)&#123;<br>        <span class="hljs-comment">//构造器是否接收props，是否传递给super取决于是否希望在构造器中通过this访问props，若要则要接要传</span><br>        <span class="hljs-keyword">super</span>(props)<br>        console.log(<span class="hljs-symbol">&#x27;constructo</span>r&#x27;,<span class="hljs-keyword">this</span>.props);<br>    &#125;<br>    static propTypes=&#123;<br>        name:<span class="hljs-type">PropTypes</span>.string.isRequired,<br>        ...<span class="hljs-comment">//对标签属性进行类型必要性的限制</span><br>    &#125;<br>    static defaultProps=&#123;<br>        ...<span class="hljs-comment">//指定默认标签属性值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="生命钩子函数"><a href="#生命钩子函数" class="headerlink" title="生命钩子函数"></a>生命钩子函数</h1><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs delphi">生命周期的三个阶段（旧）<br>一. 初始化阶段: 由ReactDOM.render()触发---初次渲染<br><span class="hljs-number">1</span>. <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">()</span></span><br><span class="hljs-function">2. <span class="hljs-title">componentWillMount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">3. <span class="hljs-title">render</span><span class="hljs-params">()</span> 常用</span><br><span class="hljs-function">4. <span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span> 常用，开启监听, 发送<span class="hljs-title">ajax</span>请求</span><br><span class="hljs-function">二. 更新阶段:</span> 由组件内部this.setSate()或父组件重新render触发<br><span class="hljs-number">1</span>. shouldComponentUpdate()<br><span class="hljs-number">2</span>. componentWillUpdate()<br><span class="hljs-number">3</span>. render()<br><span class="hljs-number">4</span>. componentDidUpdate()<br>三. 卸载组件: 由ReactDOM.unmountComponentAtNode()触发<br><span class="hljs-number">1</span>.componentWillUnmount() 常用,做一些收尾工作, 如: 清理定时器<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">生命周期的三个阶段（新）<br>一. 初始化阶段: 由ReactDOM<span class="hljs-selector-class">.render</span>()触发---初次渲染<br><span class="hljs-number">1</span><span class="hljs-selector-class">.constructor</span>()<br><span class="hljs-number">2</span><span class="hljs-selector-class">.getDerivedStateFromProps</span> <br><span class="hljs-number">3</span><span class="hljs-selector-class">.render</span>()<br><span class="hljs-number">4</span><span class="hljs-selector-class">.componentDidMount</span>()<br>二. 更新阶段: 由组件内部this<span class="hljs-selector-class">.setSate</span>()或父组件重新render触发<br><span class="hljs-number">1</span><span class="hljs-selector-class">.getDerivedStateFromProps</span><br><span class="hljs-number">2</span><span class="hljs-selector-class">.shouldComponentUpdate</span>()<br><span class="hljs-number">3</span><span class="hljs-selector-class">.render</span>()<br><span class="hljs-number">4</span><span class="hljs-selector-class">.getSnapshotBeforeUpdate</span><br><span class="hljs-number">5</span><span class="hljs-selector-class">.componentDidUpdate</span>()<br>三. 卸载组件: 由ReactDOM<span class="hljs-selector-class">.unmountComponentAtNode</span>()触发<br></code></pre></td></tr></table></figure><h2 id="案例总结"><a href="#案例总结" class="headerlink" title="案例总结"></a>案例总结</h2></li></ul><ol><li>拆分组件、实现静态组件，注意: className、 sty1e的写法</li><li>动态初始化列表，如何确定将数据放在哪个组件的state中?<br> 某个组件使用:放在其自身的state中<br> 某些组件使用:放在他们共同的父组件state中(官方称此操作为:状态提升)</li><li>关于父子之问通信:<br>一. [父组件]给[子组件]传递数据:通过props传递<br>二. [子组件]给[父组件]传递数据:通过props传递，要求父提前给子传递一一个函 数</li><li>注意defaultChecked和checked的区 别，类似的还有: defaultValue 和value</li><li>状态在哪里，操作状态的方法就在哪里</li></ol><h2 id="github搜索案例相关知识点"><a href="#github搜索案例相关知识点" class="headerlink" title="github搜索案例相关知识点"></a>github搜索案例相关知识点</h2><ol><li>设计状态时要考虑全面，例如带有网络请求的组件，要考虑请求失败怎么办。</li><li>ES6小知识点：解构赋值+重命名<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">a</span>:&#123;<span class="hljs-attr">b</span>:<span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-keyword">const</span> &#123;a&#125; = obj; <span class="hljs-comment">//传统解构赋值</span><br><span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">a</span>:&#123;b&#125;&#125; = obj; <span class="hljs-comment">//连续解构赋值</span><br><span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">a</span>:&#123;<span class="hljs-attr">b</span>:value&#125;&#125; = obj; <span class="hljs-comment">//连续解构赋值+重命名</span><br></code></pre></td></tr></table></figure></li><li>消息订阅与发布机制<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span>先订阅，再发布（理解：有一种隔空对话的感觉）<br><span class="hljs-number">2.</span>适用于任意组件间通信<br><span class="hljs-number">3.</span>要在组件的componentWillUnmount中取消订阅<br></code></pre></td></tr></table></figure></li><li>fetch发送请求（关注分离的设计思想）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">const</span> response= <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`/api1/search/users2?q=<span class="hljs-subst">$&#123;keyWord&#125;</span>`</span>)<br><span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.json()<br><span class="hljs-built_in">console</span>.log(data);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;请求出错&#x27;</span>,error);<br>&#125;<br><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string">## 路由</span><br><span class="hljs-string">路由的原理是对浏览器的history进行操作</span><br><span class="hljs-string">### 路由的基本使用</span><br><span class="hljs-string">1. 明确好界面中的导航区、展示区</span><br><span class="hljs-string">2. 导航区的a标签改为ink标签</span><br></code></pre></td></tr></table></figure><Link to=" / xxxxx" >Demo</Link><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">3.</span> 展示区写Route标签进行路径的匹配<br></code></pre></td></tr></table></figure><Route path= ' /xxxx ' component= {Demo}/ ><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml">4. <span class="hljs-tag">&lt;<span class="hljs-name">App</span>&gt;</span>的最外侧包裹了一-个<span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span>或<span class="hljs-tag">&lt;<span class="hljs-name">HashRouter</span>&gt;</span><br>### 四、路由组件与一般组件<br>1. 写法不同:<br>一般组件: <span class="hljs-tag">&lt;<span class="hljs-name">Demo</span>/&gt;</span><br>路由组件: <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot; /demo&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Demo&#125;/</span>&gt;</span><br>2. 存放位置不同:    <br>一般组件: components     <br>路由组件: pages   <br>3. 接收到的props不同: <br>一般组件:写组件标签时传递了什么，就能收到什么    <br>路由组件:接收到三个固定的属性<br></code></pre></td></tr></table></figure>      history:         go: f go(n)      goBack: f goBack()      goForward: f goForward()      push: f push(path, state)      replace: f replace(path, state)      location:      pathname: "/about"      search :      state: undefined      match :      params :      {}      path:      "/ about"      url: "/about"<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section">### 五、NavLink与封装NavLink</span><br><span class="hljs-bullet">1.</span> NavLink可以实现路由链接的高亮，通过activeClassName 指定样式名<br><span class="hljs-bullet">2.</span> 标签体内容是一个特殊的标签属性<br><span class="hljs-bullet">3.</span> 通过this. props . children可以获取标签体内容<br><br><span class="hljs-section">### 六、Switch的使用</span><br><span class="hljs-bullet">1.</span> 通常情况下，path和component是一一对应的关 系。<br><span class="hljs-bullet">2.</span> Switch可以提高路由匹配效率(单-匹配)。<br><span class="hljs-section">### 七、解决多级路径刷新页面样式丢失的问题</span><br><span class="hljs-bullet">1.</span> public/index.html中引入样式时不写./写/ (常用)<br><span class="hljs-bullet">2.</span> public/index.html中引入样式时不写./写%PUBLIC<span class="hljs-emphasis">_ _</span>URL% (常用)<br><span class="hljs-bullet">3.</span> 使用HashRouter<br><span class="hljs-section">### 八、路由的严格匹配与模糊匹配</span><br><span class="hljs-bullet">1.</span> 默认使用的是模糊匹配(简单记: [ 输入的路径]必须包含要[匹配的路径]，且顺序要一致)<br><span class="hljs-bullet">2.</span> 开启严格匹配:<br></code></pre></td></tr></table></figure><Route exact={true} path=" /about" component={About}/><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml">3. 严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由<br><br>### 九、Redirect的使用<br>1. 一般写在所有路由注册的最下方，当所有路由都无法匹配时， 跳转到Redirect指定 的路由<br>2. 具体编码:<br>```javascript<br>&lt; Switch&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot; /about&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;About&#125;/</span>&gt;</span><br>I<br><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot; /home&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;/</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>/&gt;</span><br>&lt; /Switch&gt;<br></code></pre></td></tr></table></figure>### 十、嵌套路由</li><li>注册子路由时要写上父路由的path值</li><li>路由的匹配是按照注册路由的顺序进行的</li></ol><h3 id="十一、向路由组件传递参数"><a href="#十一、向路由组件传递参数" class="headerlink" title="十一、向路由组件传递参数"></a>十一、向路由组件传递参数</h3><ol><li>params参数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> &lt;Link to= <span class="hljs-string">&#x27; /demo/test/tom/18&#x27;</span>&gt;详情&lt;<span class="hljs-regexp">/Link&gt; /</span><span class="hljs-regexp">/路由链接(携带参数)</span><br><span class="hljs-regexp"> &lt;Route path=&quot; /</span>demo/test/:name/:age<span class="hljs-string">&quot; component=&#123;Test&#125;/&gt;//注册路由(声明接收)</span><br><span class="hljs-string">const &#123;name,age&#125; = this.props.match.params//接收参数:</span><br></code></pre></td></tr></table></figure></li><li>search参数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;Link to=<span class="hljs-string">&#x27;/demo/test/?name=tom&amp;age=18&#x27;</span>&gt;详情&lt;<span class="hljs-regexp">/Link&gt;/</span><span class="hljs-regexp">/路由链接(携带参数)</span><br><span class="hljs-regexp">&lt;Route path=&quot; /</span>demo/test<span class="hljs-string">&quot; component=&#123;Test&#125;/&gt;//注册路由(无需声明，正常注册即可):</span><br><span class="hljs-string"> const &#123;search&#125; = this.props.location//接收参数</span><br><span class="hljs-string">//获取到的search是urlencoded编码字符串，需要借助querystring解析:parse方法</span><br></code></pre></td></tr></table></figure></li><li>state参数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;Link to=&#123;&#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27; /demo/test&#x27;</span> ,<span class="hljs-attr">state</span>: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span> ,<span class="hljs-attr">age</span>:<span class="hljs-number">18</span>&#125;&#125;&#125;&gt;详情&lt;<span class="hljs-regexp">/Link&gt;/</span><span class="hljs-regexp">/路由链接(携带参数)</span><br><span class="hljs-regexp">&lt;Route path=&quot; demo/</span>test<span class="hljs-string">&quot; component=&#123;Test&#125;/&gt;//注册路由(无需声明，正常注册即可)</span><br><span class="hljs-string">const &#123;name,age&#125; = this.props.location.state//接收参数</span><br><span class="hljs-string">//刷新也可以保留住参数(地址栏路由链接没了)</span><br></code></pre></td></tr></table></figure><h3 id="十二、编程式路由导肮"><a href="#十二、编程式路由导肮" class="headerlink" title="十二、编程式路由导肮"></a>十二、编程式路由导肮</h3>借助this . prosp. history对象上的API对操作路由跳转、前进、后退<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">-<span class="hljs-keyword">this</span>. prosp. history. push( )<br>-<span class="hljs-keyword">this</span>. prosp. history. replace( )<br>-<span class="hljs-keyword">this</span> . prosp. history goBack()<br>-<span class="hljs-keyword">this</span>. prosp. history. goForward()<br>-<span class="hljs-keyword">this</span> . prosp. history.go()<br></code></pre></td></tr></table></figure><h3 id="十三、withRouter使用"><a href="#十三、withRouter使用" class="headerlink" title="十三、withRouter使用"></a>十三、withRouter使用</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Header</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    ...<br>&#125;<br>export <span class="hljs-keyword">default</span> withRouter(<span class="hljs-type">Header</span>)<br><span class="hljs-comment">//withRouter可以加工一般组件，让一般组件具备路由组件所特有的API</span><br><span class="hljs-comment">//withRouter的返回值是一个新组件</span><br></code></pre></td></tr></table></figure><h3 id="十三、BrowserRouter-与HashRouter的区别"><a href="#十三、BrowserRouter-与HashRouter的区别" class="headerlink" title="十三、BrowserRouter 与HashRouter的区别"></a>十三、BrowserRouter 与HashRouter的区别</h3></li><li>底层原理不一样<br>BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。<br>HashRouter使用的是URL的哈希值。</li><li>path表现形式不一样<br>BrowserRouter的路径中没有#,例如: localhost:3000/demo/test<br>HashRouter的路径包含#,例如: localhost:3000/#/demo/test    </li><li>刷新后对路由state参数的影响<br>(1) . BrowserRouter没有任何影响，因为state保存在history对象中。<br>(2) . HashRouter刷新后会导致路由state参数的丢失。   </li><li>备注:HashRouter可以用于解决–些路径错误相关的问题。   </li></ol><h3 id="十四、antd的按需引入-自定主题"><a href="#十四、antd的按需引入-自定主题" class="headerlink" title="十四、antd的按需引入+自定主题"></a>十四、antd的按需引入+自定主题</h3><pre><code>        1.安装依赖：yarn add react-app-rewired customize-cra babel-plugin-import less less-loader        2.修改package.json                ....                    &quot;scripts&quot;: &#123;                        &quot;start&quot;: &quot;react-app-rewired start&quot;,                        &quot;build&quot;: &quot;react-app-rewired build&quot;,                        &quot;test&quot;: &quot;react-app-rewired test&quot;,                        &quot;eject&quot;: &quot;react-scripts eject&quot;                    &#125;,                ....        3.根目录下创建config-overrides.js                //配置具体的修改规则                const &#123; override, fixBabelImports,addLessLoader&#125; = require(&#39;customize-cra&#39;);                module.exports = override(                    fixBabelImports(&#39;import&#39;, &#123;                        libraryName: &#39;antd&#39;,                        libraryDirectory: &#39;es&#39;,                        style: true,                    &#125;),                    addLessLoader(&#123;                        lessOptions:&#123;                            javascriptEnabled: true,                            modifyVars: &#123; &#39;@primary-color&#39;: &#39;green&#39; &#125;,                        &#125;                    &#125;),                );            4.备注：不用在组件里亲自引入样式了，即：import &#39;antd/dist/antd.css&#39;应该删掉</code></pre><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><h3 id="1-求和案例-redux精简版"><a href="#1-求和案例-redux精简版" class="headerlink" title="1.求和案例_redux精简版"></a>1.求和案例_redux精简版</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs llvm">(<span class="hljs-number">1</span>).去除Count组件自身的状态<br>(<span class="hljs-number">2</span>).src下建立:<br>-redux<br>-<span class="hljs-keyword">store</span>.js<br>-count_reducer.js<br><br>(<span class="hljs-number">3</span>).<span class="hljs-keyword">store</span>.js：<br><span class="hljs-number">1</span>).引入redux中的createStore函数，创建一个<span class="hljs-keyword">store</span><br><span class="hljs-number">2</span>).createStore调用时要传入一个为其服务的reducer<br><span class="hljs-number">3</span>).记得暴露<span class="hljs-keyword">store</span>对象<br><br>(<span class="hljs-number">4</span>).count_reducer.js：<br><span class="hljs-number">1</span>).reducer的本质是一个函数，接收：preState<span class="hljs-punctuation">,</span>action，返回加工后的状态<br><span class="hljs-number">2</span>).reducer有两个作用：初始化状态，加工状态<br><span class="hljs-number">3</span>).reducer被第一次调用时，是<span class="hljs-keyword">store</span>自动触发的，<br>传递的preState是undefined<span class="hljs-punctuation">,</span><br>传递的action是:&#123;<span class="hljs-keyword">type</span>:&#x27;@<span class="hljs-title">@REDUX</span>/INIT_a.<span class="hljs-number">2</span>.b.<span class="hljs-number">4</span>&#125;<br><br>(<span class="hljs-number">5</span>).在index.js中监测<span class="hljs-keyword">store</span>中状态的改变，一旦发生改变重新渲染&lt;App/&gt;<br>备注：redux只负责管理状态，至于状态的改变驱动着页面的展示，要靠我们自己写<br></code></pre></td></tr></table></figure><h3 id="2-求和案例-redux完整版"><a href="#2-求和案例-redux完整版" class="headerlink" title="2.求和案例_redux完整版"></a>2.求和案例_redux完整版</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">新增文件：<br><span class="hljs-number">1</span><span class="hljs-selector-class">.count_action</span><span class="hljs-selector-class">.js</span> 专门用于创建action对象<br><span class="hljs-number">2</span><span class="hljs-selector-class">.constant</span><span class="hljs-selector-class">.js</span> 放置容易写错的type值<br></code></pre></td></tr></table></figure><h3 id="3-求和案例-redux异步action版"><a href="#3-求和案例-redux异步action版" class="headerlink" title="3.求和案例_redux异步action版"></a>3.求和案例_redux异步action版</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran">(<span class="hljs-number">1</span>).明确：延迟的动作不想交给组件自身，想交给<span class="hljs-keyword">action</span><br>(<span class="hljs-number">2</span>).何时需要异步<span class="hljs-keyword">action</span>：想要对状态进行操作，但是具体的数据靠异步任务返回。<br>(<span class="hljs-number">3</span>).具体编码：<br><span class="hljs-number">1</span>).yarn add redux-thunk，并配置在store中<br><span class="hljs-number">2</span>).创建<span class="hljs-keyword">action</span>的函数不再返回一般对象，而是一个函数，该函数中写异步任务。<br><span class="hljs-number">3</span>).异步任务有结果后，分发一个同步的<span class="hljs-keyword">action</span>去真正操作数据。<br>(<span class="hljs-number">4</span>).备注：异步<span class="hljs-keyword">action</span>不是必须要写的，完全可以自己等待异步任务的结果了再去分发同步<span class="hljs-keyword">action</span>。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题获取的小知识</title>
    <link href="/2021/09/09/%E5%88%B7%E9%A2%98%E8%8E%B7%E5%8F%96%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/09/09/%E5%88%B7%E9%A2%98%E8%8E%B7%E5%8F%96%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<ul><li>创建空白字符串可以用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-string">&#x27; &#x27;</span>).join(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li>除法取整数部分可以<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">m/n|<span class="hljs-number">0</span> 或<br>math.floor <span class="hljs-built_in">parseInt</span><br></code></pre></td></tr></table></figure></li><li>n&amp;1（位与运算）可以判断n是否为偶数如果是偶数，n&amp;1返回0；否则返回1，为奇数。</li><li>||运算符真前假后，&amp;&amp;运算符假前真后</li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javacript">可以用string.trim()去除两边空白，String.trimStart()和trimEnd()方法分别从一个字符串的开始或末端移除空白字符,而string.padEnd(targetLength [, padString])/*默认为空白*/当前字符串需要填充到的目标长度 <br></code></pre></td></tr></table></figure></li><li>可以利用reduce将普通数组转化为对象数组，如    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],b=[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br><span class="hljs-keyword">const</span> c=a.map(<span class="hljs-function">(<span class="hljs-params">v,i</span>)=&gt;</span>(&#123;<span class="hljs-attr">key</span>:v,<span class="hljs-attr">value</span>:b[i]&#125;));<span class="hljs-comment">//注意不用return的话，使用(&#123;&#125;)的情况返回对象要用（）包裹</span><br><span class="hljs-built_in">console</span>.log(c)<br><span class="hljs-comment">// [&#123;&quot;key&quot;:1,&quot;value&quot;:5&#125;,&#123;&quot;key&quot;:2,&quot;value&quot;:4&#125;,&#123;&quot;key&quot;:3,&quot;value&quot;:3&#125;,&#123;&quot;key&quot;:4,&quot;value&quot;:2&#125;,&#123;&quot;key&quot;:5,&quot;value&quot;:1&#125;]</span><br></code></pre></td></tr></table></figure></li><li>x**n  相当于 Math.pow(x,n)  即x的n次方</li><li>Array.filter()返回一个新数组，一个也要用[0],Array.find()返回数组中满足提供的测试函数的第一个元素的值</li><li>String.localeCompare()返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同，经常用于字典序的排序</li><li>「二分」不是单纯指从有序数组中快速找某个数，这只是「二分」的一个应用。<br>「二分」的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用「二分」。「二段性」还能继续细分，不仅仅只有满足 01 特性（满足/不满足）的「二段性」可以使用二分，满足 1? 特性（一定满足/不一定满足）也可以二分。（力扣162）</li><li>已知 randN() 可以等概率的生成[1, N]范围的随机数,那么：(randX() - 1) × Y + randY() ==&gt; 可以等概率的生成[1, X * Y]范围的随机数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRndInteger</span>(<span class="hljs-params">min, max</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (max - min) ) + min;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>可以利用二进制数记录01状态，初始化一个数组arr，如一个数num出现过则是arr[i]|=(1&lt;&lt;num)使相对应位置变为1，判断则arr[i]&gt;&gt;num&amp;1进行判断，若为1则出现过，0则反之</li><li>正则：\s匹配任何空白字符，包括空格、制表符、换页符等等，\S匹配任何非空白字符。等价于 [^ \f\n\r\t\v],匹配非空白字符用string.match(/\S+/g)或str.trim().split(/\s+/) //注意要加trim()方法</li><li>判断两数符号位让两数作异或运算x^y,如果两个整数的符号位相反，那么异或的结果就会让最高位的符号位为1，也就是异或得到的数会小于0，反之大于等于0则表示两个正数符号位相同</li><li>关于求是否为某数的幂运算得到的值,取巧可以打表或者在范围内取最大值看这个是是否为最大值的质数即可</li><li>map不改变原数组</li><li>取整Math.floor(x/2)时可以用x/2|0或x&gt;&gt;1(可能存在不如前者可接受最大位数多的精度问题，如力扣441二分用&gt;&gt;1时存在溢出成负数)</li><li>数字取补数可以通过和二进制全是1的数字进行异或操作</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法，函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣628 三个数的最大乘积</title>
    <link href="/2021/01/21/%E5%8A%9B%E6%89%A3628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/"/>
    <url>/2021/01/21/%E5%8A%9B%E6%89%A3628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p> </p><p>示例 1：<br>输入：nums = [1,2,3]<br>输出：6</p><p>示例 2：<br>输入：nums = [1,2,3,4]<br>输出：24</p><p>示例 3：<br>输入：nums = [-1,-2,-3]<br>输出：-6</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers">https://leetcode-cn.com/problems/maximum-product-of-three-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一开始想排序后直接求，后发现有负数数据，那头尾进行比较即可<br>好久没做题了，今天开始准备恢复吧，连宇哥都好久没发题解了</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maximumProduct = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    nums.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span> b-a);<br>    <span class="hljs-keyword">const</span> n =nums.length;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(nums[<span class="hljs-number">0</span>]*nums[<span class="hljs-number">1</span>]*nums[<span class="hljs-number">2</span>],nums[<span class="hljs-number">0</span>]*nums[n-<span class="hljs-number">1</span>]*nums[n-<span class="hljs-number">2</span>]);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="线性扫描"><a href="#线性扫描" class="headerlink" title="线性扫描"></a>线性扫描</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maximumProduct = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-comment">// 最小的和第二小的</span><br>    <span class="hljs-keyword">let</span> min1 = <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER, min2 = <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER;<br>    <span class="hljs-comment">// 最大的、第二大的和第三大的</span><br>    <span class="hljs-keyword">let</span> max1 = -<span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER, max2 = -<span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER, max3 = -<span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> nums) &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; min1) &#123;<br>            min2 = min1;<br>            min1 = x;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt; min2) &#123;<br>            min2 = x;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (x &gt; max1) &#123;<br>            max3 = max2;<br>            max2 = max1;<br>            max1 = x;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; max2) &#123;<br>            max3 = max2;<br>            max2 = x;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; max3) &#123;<br>            max3 = x;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(min1 * min2 * max1, max1 * max2 * max3);<br>&#125;;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/maximum-product-of-three-numbers/solution/san-ge-shu-de-zui-da-cheng-ji-by-leetcod-t9sb/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>力扣830 较大分组的位置</title>
    <link href="/2021/01/05/%E5%8A%9B%E6%89%A3830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <url>/2021/01/05/%E5%8A%9B%E6%89%A3830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 s = “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。</p><p>分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 “xxxx” 分组用区间表示为 [3,6] 。</p><p>我们称所有包含大于或等于三个连续字符的分组为 较大分组 。</p><p>找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。</p><p> </p><p>示例 1：<br>输入：s = “abbxxxxzzy”<br>输出：[[3,6]]<br>解释：”xxxx” 是一个起始于 3 且终止于 6 的较大分组。</p><p>示例 2：<br>输入：s = “abc”<br>输出：[]<br>解释：”a”,”b” 和 “c” 均不是符合要求的较大分组。</p><p>示例 3：<br>输入：s = “abcdddeeeeaabbbcd”<br>输出：[[3,5],[6,9],[12,14]]<br>解释：较大分组为 “ddd”, “eeee” 和 “bbb”</p><p>示例 4：<br>输入：s = “aba”<br>输出：[]<br> <br>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>s 仅含小写英文字母</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/positions-of-large-groups">https://leetcode-cn.com/problems/positions-of-large-groups</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-正则"><a href="#一-正则" class="headerlink" title="一 正则"></a>一 正则</h4><p>([a-z])捕获小写字母，\1反向引用刚才捕获的字母，{2,}该字母又出现&gt;=2次  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">matchAll<br><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> g = s.matchAll(<span class="hljs-regexp">/([a-z])\1&#123;2,&#125;/g</span>), r = [], t<br>    <span class="hljs-keyword">while</span> (t = g.next().value) r.push([t.index, t.index + t[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br><br><br><br><br>matchAll · <span class="hljs-number">1</span>行代码<br><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(s.matchAll(<span class="hljs-regexp">/(.)\1\1+/g</span>), <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> [v.index, v.index + v[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>])<br>&#125;;<br><br><br><br>replace：.匹配除换行符以外的任意字符<br><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> r = []<br>    s.replace(<span class="hljs-regexp">/(.)\1&#123;2,&#125;/g</span>, <span class="hljs-function">(<span class="hljs-params">a, _, i</span>)=&gt;</span> r.push([i, i + a.length - <span class="hljs-number">1</span>]))<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/positions-of-large-groups/solution/zheng-ze-wei-zhan-3jie-fa-chao-100-by-ma-r0vy/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-扫描"><a href="#二-扫描" class="headerlink" title="二 扫描"></a>二 扫描</h4><p>start不同字母首次出现索引，初始0。遍历遇下个不同字母，更新start</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript">字母<br><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>, r = []<br>    <span class="hljs-keyword">while</span> (++i &lt;= s.length) <br>        <span class="hljs-keyword">if</span> (s[start] !== s[i]) &#123;<br>            <span class="hljs-keyword">if</span> (i - start &gt; <span class="hljs-number">2</span>) r.push([start, i - <span class="hljs-number">1</span>])<br>            start = i<br>        &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br><br><br>位运算 · 异或：字母转Unicode编码，相同^为<span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>, r = []<br>    <span class="hljs-keyword">while</span> (++i &lt;= s.length) <br>        <span class="hljs-keyword">if</span> (s.charCodeAt(start) ^ s.charCodeAt(i)) &#123;<br>            <span class="hljs-keyword">if</span> (i - start &gt; <span class="hljs-number">2</span>) r.push([start, i - <span class="hljs-number">1</span>])<br>            start = i<br>        &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br><br><br><br><span class="hljs-built_in">Proxy</span>：拦截数组push方法，不满足连续出现次数&gt;=<span class="hljs-number">3</span>不真正push<br><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>, r = [], p = proxy(r)<br>    <span class="hljs-keyword">while</span> (++i &lt;= s.length) <br>        <span class="hljs-keyword">if</span> (s[start] !== s[i]) &#123;<br>            p.push([start, i - <span class="hljs-number">1</span>])<br>            start = i<br>        &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(r, &#123;<br>    set (t, p, v) &#123;         <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> v === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; v[<span class="hljs-number">1</span>] - v[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>) t[p] = v<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>&#125;)<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/positions-of-large-groups/solution/zheng-ze-wei-zhan-3jie-fa-chao-100-by-ma-r0vy/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="三-位"><a href="#三-位" class="headerlink" title="三 位"></a>三 位</h4><p>小写字母转Unicode编码-97，范围[0, 25]。二进制的32位从左到右[1, 26]位可表示[a, z]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bit</span> </span>&#123; <span class="hljs-comment">// 构造Bit类，模仿Set，当Set用</span><br>    <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">this</span>.clear()<br>    &#125;<br>    add (v) &#123; <span class="hljs-comment">// 遇 a 转97，再-97 = 0，1左移0位 = 1。或 运算，占第1位</span><br>        <span class="hljs-built_in">this</span>.bit |= <span class="hljs-number">1</span> &lt;&lt; v<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>    &#125;<br>    has (v) &#123; <span class="hljs-comment">// 再遇 a，同上，1左移0位 = 1。且 运算，第1位已被占，找到连续 a</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.bit &amp; <span class="hljs-number">1</span> &lt;&lt; v<br>    &#125;<br>    clear () &#123;<br>        <span class="hljs-built_in">this</span>.bit = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>    &#125;<br>&#125;<br><br><br><br><br>构造Bit类，遇不同字母(has返回<span class="hljs-number">0</span>)，清空Bit并放入。相当于用!Bit.has代替上解法的!==<br><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>, b = <span class="hljs-keyword">new</span> Bit, r = [], t<br>    b.add(s.charCodeAt(<span class="hljs-number">0</span>) - <span class="hljs-number">97</span>)<br>    <span class="hljs-keyword">while</span> (++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">if</span> (!b.has(t = s.charCodeAt(i) - <span class="hljs-number">97</span>)) &#123;<br>            <span class="hljs-keyword">if</span> (i - start &gt; <span class="hljs-number">2</span>) r.push([start, i - <span class="hljs-number">1</span>])<br>            start = i<br>            b.clear().add(t)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i - start &gt; <span class="hljs-number">2</span>) r.push([start, i - <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br><br><br><br>提示<br>Bit作用与<span class="hljs-built_in">Set</span>一致，即判断字母是否重复出现。只是!<span class="hljs-built_in">Set</span>.has字母不如直接!==快<br><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>, b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(s[<span class="hljs-number">0</span>]), r = [], t<br>    <span class="hljs-keyword">while</span> (++i &lt;= s.length) <br>        <span class="hljs-keyword">if</span> (!b.has(s[i])) &#123;<br>            <span class="hljs-keyword">if</span> (i - start &gt; <span class="hljs-number">2</span>) r.push([start, i - <span class="hljs-number">1</span>])<br>            start = i<br>            b.clear()<br>            b.add(s[i])<br>        &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/positions-of-large-groups/solution/zheng-ze-wei-zhan-3jie-fa-chao-100-by-ma-r0vy/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="四-栈"><a href="#四-栈" class="headerlink" title="四 栈"></a>四 栈</h4><p>构造特殊栈：push时，遇不同元素，清空栈 并 返回清空前的长度，该长度即相同元素个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>&#123;<br>    <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">this</span>.q = []<br>    &#125; <br>    length () &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.q.length<br>    &#125;<br>    top () &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.q[<span class="hljs-built_in">this</span>.length() - <span class="hljs-number">1</span>]<br>    &#125;<br>    clear () &#123;<br>        <span class="hljs-built_in">this</span>.q.length = <span class="hljs-number">0</span><br>    &#125;<br>    push (v) &#123;<br>        <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> (v !== <span class="hljs-built_in">this</span>.top()) &#123;<br>            len = <span class="hljs-built_in">this</span>.length()<br>            <span class="hljs-built_in">this</span>.clear()<br>        &#125;<br>        <span class="hljs-built_in">this</span>.q.push(v)<br>        <span class="hljs-keyword">return</span> len<br>    &#125;<br>&#125;<br><br><br><br>遍历将元素放入栈，找 相同元素个数&gt;=<span class="hljs-number">3</span> 即可<br><span class="hljs-keyword">var</span> largeGroupPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>, q = <span class="hljs-keyword">new</span> Stack, r = []<br>    <span class="hljs-keyword">while</span> (++i &lt;= s.length) &#123;<br>        <span class="hljs-keyword">const</span> n = q.push(s[i])<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">2</span>) r.push([i - n, i - <span class="hljs-number">1</span>])<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/positions-of-large-groups/solution/zheng-ze-wei-zhan-3jie-fa-chao-100-by-ma-r0vy/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>正则</tag>
      
      <tag>位</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣509 斐波那契数</title>
    <link href="/2021/01/04/%E5%8A%9B%E6%89%A3509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
    <url>/2021/01/04/%E5%8A%9B%E6%89%A3509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给你 n ，请计算 F(n) 。</p><p> </p><p>示例 1：<br>输入：2<br>输出：1<br>解释：F(2) = F(1) + F(0) = 1 + 0 = 1</p><p>示例 2：<br>输入：3<br>输出：2<br>解释：F(3) = F(2) + F(1) = 1 + 1 = 2</p><p>示例 3：<br>输入：4<br>输出：3<br>解释：F(4) = F(3) + F(2) = 2 + 1 = 3 </p><p>提示：</p><p>0 &lt;= n &lt;= 30</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/fibonacci-number">https://leetcode-cn.com/problems/fibonacci-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-递归"><a href="#一-递归" class="headerlink" title="一 递归"></a>一 递归</h4><h5 id="1-1-递归"><a href="#1-1-递归" class="headerlink" title="1.1 递归"></a>1.1 递归</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> N === <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : N &lt; <span class="hljs-number">3</span> ? <span class="hljs-number">1</span> : fib(N - <span class="hljs-number">1</span>) + fib(N - <span class="hljs-number">2</span>)<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/fibonacci-number/solution/yang-hui-san-jiao-bi-nei-ju-zhen-di-gui-0cbrm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="1-2-记忆化递归"><a href="#1-2-记忆化递归" class="headerlink" title="1.2 记忆化递归"></a>1.2 记忆化递归</h5><p>递归函数变化参数为N，作为哈希表键名，缓存结果。递归到底，回溯遇相同N不再递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">数组<br><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N, h = <span class="hljs-built_in">Array</span>(N)</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> N === <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : N &lt; <span class="hljs-number">3</span> ? <span class="hljs-number">1</span> : h[N] ? h[N] : h[N] = fib(N - <span class="hljs-number">1</span>, h) + fib(N - <span class="hljs-number">2</span>, h)<br>&#125;;<br><br><br><br><br><span class="hljs-built_in">Object</span><br><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N, h = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> N === <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : N &lt; <span class="hljs-number">3</span> ? <span class="hljs-number">1</span> : h[N] ? h[N] : h[N] = fib(N - <span class="hljs-number">1</span>, h) + fib(N - <span class="hljs-number">2</span>, h)<br>&#125;;<br><br><br><br><br><span class="hljs-built_in">Map</span><br><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> N === <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : N &lt; <span class="hljs-number">3</span> ? <span class="hljs-number">1</span> : (!h.has(N) &amp;&amp; h.set(N, fib(N - <span class="hljs-number">1</span>, h) + fib(N - <span class="hljs-number">2</span>, h)), h.get(N))<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/fibonacci-number/solution/yang-hui-san-jiao-bi-nei-ju-zhen-di-gui-0cbrm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-动态规划"><a href="#二-动态规划" class="headerlink" title="二 动态规划"></a>二 动态规划</h4><h5 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h5><p>dp[i]表示F(i) 已知dp[0] = 0 dp[1] = 1 状态转换方程即递推方程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(N + <span class="hljs-number">1</span>), i = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; N) dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">return</span> N ? dp[N] : <span class="hljs-number">0</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/fibonacci-number/solution/yang-hui-san-jiao-bi-nei-ju-zhen-di-gui-0cbrm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="2-2-滚动数组"><a href="#2-2-滚动数组" class="headerlink" title="2.2 滚动数组"></a>2.2 滚动数组</h5><p>dp[1]代替dp[i] 上轮dp[1]代替dp[i - 1] dp[0]代替dp[i - 2] 滚动：dp[0] = 上轮dp[1]<br>中间变量：暂存上轮dp[1]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> dp = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; N) &#123;<br>        <span class="hljs-keyword">const</span> tmp = dp[<span class="hljs-number">1</span>]<br>        dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">0</span>] + dp[<span class="hljs-number">1</span>]<br>        dp[<span class="hljs-number">0</span>] = tmp<br>    &#125;<br>    <span class="hljs-keyword">return</span> N ? dp[<span class="hljs-number">1</span>] : <span class="hljs-number">0</span><br>&#125;;<br><br><br><br>运算顺序：先读取+号左边dp[<span class="hljs-number">0</span>]，再赋值扣号内dp[<span class="hljs-number">0</span>]，省去中间变量<br><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> dp = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; N) dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">0</span>] + (dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> N ? dp[<span class="hljs-number">1</span>] : <span class="hljs-number">0</span><br>&#125;;<br><br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/fibonacci-number/solution/yang-hui-san-jiao-bi-nei-ju-zhen-di-gui-0cbrm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="2-3-状态机"><a href="#2-3-状态机" class="headerlink" title="2.3 状态机"></a>2.3 状态机</h5><p>用两个变量，分别代替dp[1]和dp[0]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> s0 = <span class="hljs-number">0</span>, s1 = <span class="hljs-number">1</span>, i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; N) s1 = s0 + (s0 = s1)<br>    <span class="hljs-keyword">return</span> N ? s1 : <span class="hljs-number">0</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/fibonacci-number/solution/yang-hui-san-jiao-bi-nei-ju-zhen-di-gui-0cbrm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="三-哈希表"><a href="#三-哈希表" class="headerlink" title="三 哈希表"></a>三 哈希表</h4><p>通过5.1动态规划得到[0,30]所有解，存到哈希表中，面向测试用例编程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">34</span>,<span class="hljs-number">55</span>,<span class="hljs-number">89</span>,<span class="hljs-number">144</span>,<span class="hljs-number">233</span>,<span class="hljs-number">377</span>,<span class="hljs-number">610</span>,<span class="hljs-number">987</span>,<span class="hljs-number">1597</span>,<span class="hljs-number">2584</span>,<span class="hljs-number">4181</span>,<span class="hljs-number">6765</span>,<span class="hljs-number">10946</span>,<span class="hljs-number">17711</span>,<span class="hljs-number">28657</span>,<span class="hljs-number">46368</span>,<span class="hljs-number">75025</span>,<span class="hljs-number">121393</span>,<span class="hljs-number">196418</span>,<span class="hljs-number">317811</span>,<span class="hljs-number">514229</span>,<span class="hljs-number">832040</span>][N]<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/fibonacci-number/solution/yang-hui-san-jiao-bi-nei-ju-zhen-di-gui-0cbrm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="四-杨辉三角"><a href="#四-杨辉三角" class="headerlink" title="四 杨辉三角"></a>四 杨辉三角</h4><p>杨辉三角左对齐后的对角线累加和即斐波那契数列。<br><a href="https://imgchr.com/i/si8dhR"><img src="https://s3.ax1x.com/2021/01/04/si8dhR.png" alt="si8dhR.png"></a></p><h5 id="4-1-相邻"><a href="#4-1-相邻" class="headerlink" title="4.1 相邻"></a>4.1 相邻</h5><p>生成杨辉三角：中间位 = 上一行相邻元素和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> M = generate(N), r = <span class="hljs-number">0</span>, i = N, j = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i-- &amp;&amp; ++j &lt; M[i].length) r += M[i][j]<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><span class="hljs-keyword">var</span> generate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">numRows</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>(numRows).fill().map(<span class="hljs-function">(<span class="hljs-params">_, i, r</span>) =&gt;</span> r[i] = <span class="hljs-built_in">Array</span>(i + <span class="hljs-number">1</span>).fill(<span class="hljs-number">1</span>).map(<span class="hljs-function">(<span class="hljs-params">v, j</span>) =&gt;</span> j &gt; <span class="hljs-number">0</span> &amp;&amp; j &lt; i ? r[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + r[i - <span class="hljs-number">1</span>][j] : v))<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/fibonacci-number/solution/yang-hui-san-jiao-bi-nei-ju-zhen-di-gui-0cbrm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="4-2-对称性"><a href="#4-2-对称性" class="headerlink" title="4.2 对称性"></a>4.2 对称性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">生成杨辉三角：用对称性，从两端到中间，同时赋值j和i - j<br><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> M = generate(N), r = <span class="hljs-number">0</span>, i = N, j = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i-- &amp;&amp; ++j &lt; M[i].length) r += M[i][j]<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><span class="hljs-keyword">var</span> generate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">numRows</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(numRows); i &lt; numRows; i++) &#123;<br>        r[i] = i &lt; <span class="hljs-number">10</span> ? <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(i + <span class="hljs-number">1</span>) : i &lt; <span class="hljs-number">19</span> ? <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(i + <span class="hljs-number">1</span>) : <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(i + <span class="hljs-number">1</span>)<br>        r[i][<span class="hljs-number">0</span>] = r[i][i] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt;= i &gt;&gt; <span class="hljs-number">1</span>; j++) <br>            r[i][j] = r[i][i - j] = r[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + r[i - <span class="hljs-number">1</span>][j]<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/fibonacci-number/solution/yang-hui-san-jiao-bi-nei-ju-zhen-di-gui-0cbrm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="五-比内公式"><a href="#五-比内公式" class="headerlink" title="五 比内公式"></a>五 比内公式</h4><p><a href="https://imgchr.com/i/si8UAJ"><img src="https://s3.ax1x.com/2021/01/04/si8UAJ.png" alt="si8UAJ.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> s5 = <span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">.5</span> + s5 / <span class="hljs-number">2</span>, N) - <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">.5</span> - s5 / <span class="hljs-number">2</span>, N)) / s5<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/fibonacci-number/solution/yang-hui-san-jiao-bi-nei-ju-zhen-di-gui-0cbrm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="六-矩阵快速幂"><a href="#六-矩阵快速幂" class="headerlink" title="六 矩阵快速幂"></a>六 矩阵快速幂</h4><p>6.1 整数快速幂</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pow = <span class="hljs-function">(<span class="hljs-params">M, N</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(N) &#123;<br>        <span class="hljs-keyword">if</span> (N &amp; <span class="hljs-number">1</span>) r *= M<br>        M *= M<br>        N &gt;&gt;= <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/fibonacci-number/solution/yang-hui-san-jiao-bi-nei-ju-zhen-di-gui-0cbrm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="6-2-矩阵快速幂"><a href="#6-2-矩阵快速幂" class="headerlink" title="6.2 矩阵快速幂"></a>6.2 矩阵快速幂</h4><p>整数换成矩阵</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pow = <span class="hljs-function">(<span class="hljs-params">M, N</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> r = [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]<br>    <span class="hljs-keyword">while</span>(N) &#123;<br>        <span class="hljs-keyword">if</span> (N &amp; <span class="hljs-number">1</span>) r = multiply(r, M)<br>        M = multiply(M, M)<br>        N &gt;&gt;= <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;<br><br><br><br>矩阵乘法<br><span class="hljs-keyword">const</span> multiply = <span class="hljs-function">(<span class="hljs-params">M1, M2</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> r = <span class="hljs-built_in">Array</span>.from(&#123;<span class="hljs-attr">length</span>: M1.length&#125;, <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(M2[<span class="hljs-number">0</span>].length))<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; M1.length; i++) <span class="hljs-comment">// 遍历矩阵，水平扫描 缓存命中率 &gt; 垂直扫描</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; M1[<span class="hljs-number">0</span>].length; j++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; M2[<span class="hljs-number">0</span>].length; k++) <br>                r[i][k] += M1[i][j] * M2[j][k]<br>    <span class="hljs-keyword">return</span> r<br>&#125;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/fibonacci-number/solution/yang-hui-san-jiao-bi-nei-ju-zhen-di-gui-0cbrm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/si8aN9"><img src="https://s3.ax1x.com/2021/01/04/si8aN9.png" alt="si8aN9.png"></a><br>求解：M = [[1, 1], [1, 0]] F(N) = M的N - 1次方[0][0]项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fib = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> M = [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]]<br>    <span class="hljs-keyword">return</span> N ? pow(M, N - <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] : <span class="hljs-number">0</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/fibonacci-number/solution/yang-hui-san-jiao-bi-nei-ju-zhen-di-gui-0cbrm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>动态规划</tag>
      
      <tag>杨辉三角</tag>
      
      <tag>比内</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣86 分隔链表</title>
    <link href="/2021/01/03/%E5%8A%9B%E6%89%A386-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/01/03/%E5%8A%9B%E6%89%A386-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p> </p><p>示例：<br>输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/partition-list">https://leetcode-cn.com/problems/partition-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-链头"><a href="#一-链头" class="headerlink" title="一 链头"></a>一 链头</h4><p>&lt;目标值放链表a，&gt;=放链表b，拼接链表a和b<br>头部节点不确定时，用虚拟链头指向头部。拼接和返回虚拟链头.next即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> partition = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, x</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> pA = a = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>), pB = b = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">while</span> (head) &#123;<br>        head.val &lt; x ? a = a.next = head : b = b.next = head<br>        head = head.next<br>    &#125;<br>    a.next = pB.next<br>    b.next = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> pA.next<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/partition-list/solution/lian-tou-shu-zu-shuang-zhi-zhen-7xing-da-baxz/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-数组"><a href="#二-数组" class="headerlink" title="二 数组"></a>二 数组</h4><p>&lt;目标值放数组a，&gt;=放数组b，拼接数组a和b</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> partition = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, x</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a = [], b = [], i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (head) &#123;<br>        head.val &lt; x ? a.push(head) : b.push(head)<br>        head = head.next<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> b[<span class="hljs-number">0</span>] || head<br>    <span class="hljs-keyword">while</span> (++i &lt;= a.length) a[i - <span class="hljs-number">1</span>].next = a[i] || b[<span class="hljs-number">0</span>] || <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= b.length; i++) b[i - <span class="hljs-number">1</span>].next = b[i] || <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/partition-list/solution/lian-tou-shu-zu-shuang-zhi-zhen-7xing-da-baxz/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="三-双指针"><a href="#三-双指针" class="headerlink" title="三 双指针"></a>三 双指针</h4><p>慢指针只在&lt;目标值移动，快指针始终移动</p><p>慢指针停在&gt;=目标值时，如果快指针&lt;目标值，移动快指针节点到慢指针节点前<br>删除：快指针上节点 → 快指针下节点<br>插入：慢指针上节点 → 快指针节点 → 慢指针节点<br><a href="https://imgchr.com/i/siUDgA"><img src="https://s3.ax1x.com/2021/01/04/siUDgA.png" alt="siUDgA.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> partition = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, x</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">let</span> p = prevSlow = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>), prevFast = slow = head, fast = head.next<br>    prevSlow.next = head<br>    <span class="hljs-keyword">while</span> (fast) &#123;<br>        <span class="hljs-keyword">if</span> (slow.val &lt; x) &#123;<br>            prevSlow = slow<br>            slow = slow.next<br>            prevFast = fast<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fast.val &lt; x) &#123;<br>            prevFast.next = fast.next<br>            prevSlow.next = fast<br>            fast.next = slow<br>            prevSlow = fast<br>        &#125; <span class="hljs-keyword">else</span> prevFast = fast<br>        fast = prevFast.next<br>    &#125;<br>    <span class="hljs-keyword">return</span> p.next<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/partition-list/solution/lian-tou-shu-zu-shuang-zhi-zhen-7xing-da-baxz/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="四-双指针-·-优化"><a href="#四-双指针-·-优化" class="headerlink" title="四 双指针 · 优化"></a>四 双指针 · 优化</h4><p>原双指针代码中，用prevSlow.next代替slow head代替prevFast 再将prevSlow写成slow</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> partition = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, x</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">let</span> p = slow = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>), fast = head.next<br>    slow.next = head<br>    <span class="hljs-keyword">while</span> (fast) &#123;<br>        <span class="hljs-keyword">if</span> (slow.next.val &lt; x) &#123;<br>            slow = slow.next<br>            head = fast<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fast.val &lt; x) &#123;<br>            head.next = fast.next<br>            fast.next = slow.next<br>            slow = slow.next = fast<br>        &#125; <span class="hljs-keyword">else</span> head = fast<br>        fast = head.next<br>    &#125;<br>    <span class="hljs-keyword">return</span> p.next<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/partition-list/solution/lian-tou-shu-zu-shuang-zhi-zhen-7xing-da-baxz/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="五-Fiber"><a href="#五-Fiber" class="headerlink" title="五 Fiber"></a>五 Fiber</h4><p>React Fiber：&gt;=目标值节点放入tag链表并从原链表删除。拼接原链表最后节点和tag</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> partition = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, x</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> p = prev = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>), pTag = tag = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>)<br>    prev.next = head<br>    <span class="hljs-keyword">while</span> (head) &#123;<br>        <span class="hljs-keyword">if</span> (head.val &gt;= x) &#123;<br>            prev.next = head.next<br>            tag = tag.next = head<br>        &#125; <span class="hljs-keyword">else</span> prev = head<br>        head = head.next<br>    &#125;<br>    tag.next = <span class="hljs-literal">null</span><br>    prev.next = pTag.next<br>    <span class="hljs-keyword">return</span> p.next<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/partition-list/solution/lian-tou-shu-zu-shuang-zhi-zhen-7xing-da-baxz/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>数组</tag>
      
      <tag>链头</tag>
      
      <tag>Fiber</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣239 滑动窗口最大值</title>
    <link href="/2021/01/02/%E5%8A%9B%E6%89%A3239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2021/01/02/%E5%8A%9B%E6%89%A3239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p> </p><p>示例 1：<br>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值 </p><hr><p>[1  3  -1] -3  5  3  6  7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br> 1 [3  -1  -3] 5  3  6  7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3<br> 1  3 [-1  -3  5] 3  6  7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5<br> 1  3  -1 [-3  5  3] 6  7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5<br> 1  3  -1  -3 [5  3  6] 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6<br> 1  3  -1  -3  5 [3  6  7]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7  </p><p>示例 2：<br>输入：nums = [1], k = 1<br>输出：[1]  </p><p>示例 3：<br>输入：nums = [1,-1], k = 1<br>输出：[1,-1]  </p><p>示例 4：<br>输入：nums = [9,11], k = 2<br>输出：[11] </p><p>示例 5：<br>输入：nums = [4,-2], k = 2<br>输出：[4] </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sliding-window-maximum">https://leetcode-cn.com/problems/sliding-window-maximum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最近有点懈怠了准备找状态了。。         2021.1.2</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-计数"><a href="#一-计数" class="headerlink" title="一 计数"></a>一 计数</h4><p>索引数 + 10000（负转正），值出现次数。最大：倒序遍历，索引大 → 小，第一个值不为0<br>向右移动，新数出现次数+1，最左边数出现次数-1。最大放入结果集即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxSlidingWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(<span class="hljs-number">20001</span>), r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(nums.length - k + <span class="hljs-number">1</span>), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; k) h[nums[i] + <span class="hljs-number">10000</span>]++<br>    r[<span class="hljs-number">0</span>] = max(h), i--<br>    <span class="hljs-keyword">while</span>(++i &lt; nums.length) &#123;<br>        h[nums[i] + <span class="hljs-number">10000</span>]++<br>        h[nums[i - k] + <span class="hljs-number">10000</span>]--<br>        r[i - k + <span class="hljs-number">1</span>] = max(h)<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>max = <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> j = <span class="hljs-number">20001</span><br>    <span class="hljs-keyword">while</span>(h[--j] === <span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-keyword">return</span> j - <span class="hljs-number">10000</span><br>&#125;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/sliding-window-maximum/solution/ji-shu-shuang-duan-fen-kuai-you-xian-5xi-87ud/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-双端"><a href="#二-双端" class="headerlink" title="二 双端"></a>二 双端</h4><h5 id="2-1-数"><a href="#2-1-数" class="headerlink" title="2.1 数"></a>2.1 数</h5><p>单调递减队列，特点是欺软怕硬：新元素会删比它小的数，排在比它大的数后<br>向右移动，新数放队列，最左边数是最大删，不是最大（已经被比它大的删过）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxSlidingWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = [], r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(nums.length - k + <span class="hljs-number">1</span>), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; k) q.push(max(nums[i], q))<br>    r[<span class="hljs-number">0</span>] = q[<span class="hljs-number">0</span>], i--<br>    <span class="hljs-keyword">while</span> (++i &lt; nums.length) &#123;<br>        q.push(max(nums[i], q))<br>        <span class="hljs-keyword">if</span> (q[<span class="hljs-number">0</span>] === nums[i - k]) q.shift()<br>        r[i - k + <span class="hljs-number">1</span>] = q[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>max = <span class="hljs-function">(<span class="hljs-params">n, q</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">while</span> (n &gt; q[q.length - <span class="hljs-number">1</span>]) q.pop()<br>    <span class="hljs-keyword">return</span> n<br>&#125;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/sliding-window-maximum/solution/ji-shu-shuang-duan-fen-kuai-you-xian-5xi-87ud/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="2-2-索引"><a href="#2-2-索引" class="headerlink" title="2.2 索引"></a>2.2 索引</h5><p>队列存索引，而不是数。数相等时，可以全删，保留自己<br>最左边数比较的是最大数索引。数相同，索引不同，不会多删</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxSlidingWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = [], r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(nums.length - k + <span class="hljs-number">1</span>), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; k) q.push(max(nums, q, i))<br>    r[<span class="hljs-number">0</span>] = nums[q[<span class="hljs-number">0</span>]], i--<br>    <span class="hljs-keyword">while</span> (++i &lt; nums.length) &#123;<br>        q.push(max(nums, q, i))<br>        <span class="hljs-keyword">if</span> (q[<span class="hljs-number">0</span>] === i - k) q.shift()<br>        r[i - k + <span class="hljs-number">1</span>] = nums[q[<span class="hljs-number">0</span>]]<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>max = <span class="hljs-function">(<span class="hljs-params">nums, q, i</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">while</span> (nums[i] &gt;= nums[q[q.length - <span class="hljs-number">1</span>]]) q.pop() <span class="hljs-comment">// &gt;=</span><br>    <span class="hljs-keyword">return</span> i<br>&#125;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/sliding-window-maximum/solution/ji-shu-shuang-duan-fen-kuai-you-xian-5xi-87ud/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>[-7,-8,7,5,7,1,6,0]<br>4<br>该测试用例可以说明：为什么队列存数时必须&gt;而索引可以&gt;=</p><h4 id="三-分块"><a href="#三-分块" class="headerlink" title="三 分块"></a>三 分块</h4><p>将数组分成k块</p><p>指针j → 统计每块内从块开头到j最大值<br>指针i ← 统计每块内从块结尾到i最大值<br>滑动区间[i, i + k - 1]最大值 = 某块结尾到i最大值 与 某块开头到i + k - 1最大值取大<br><a href="https://imgchr.com/i/spFWGt"><img src="https://s3.ax1x.com/2021/01/02/spFWGt.md.png" alt="spFWGt.md.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxSlidingWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = nums.length, p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(n), s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(n), r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(n - k + <span class="hljs-number">1</span>), i = n, j = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>        p[++j] = j % k ? <span class="hljs-built_in">Math</span>.max(p[j - <span class="hljs-number">1</span>], nums[j]) : nums[j]<br>        s[i]   = i % k ? <span class="hljs-built_in">Math</span>.max(s[i + <span class="hljs-number">1</span>], nums[i]) : nums[i]<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i++ &lt; n - k) r[i] = <span class="hljs-built_in">Math</span>.max(s[i], p[i + k - <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> r<br>&#125;; <br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/sliding-window-maximum/solution/ji-shu-shuang-duan-fen-kuai-you-xian-5xi-87ud/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="四-优先"><a href="#四-优先" class="headerlink" title="四 优先"></a>四 优先</h4><p>优先队列只能顶端弹出最大值。每次删最左边数只能依靠第二参数索引来避免多删</p><h5 id="4-1-MaxPriorityQueue"><a href="#4-1-MaxPriorityQueue" class="headerlink" title="4.1 MaxPriorityQueue"></a>4.1 MaxPriorityQueue</h5><p>力扣封装的JS大根堆优先队列，优先权重参数必须为正数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxSlidingWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = <span class="hljs-keyword">new</span> MaxPriorityQueue, r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(nums.length - k + <span class="hljs-number">1</span>), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; k) q.enqueue(i, nums[i] + <span class="hljs-number">10001</span>)<br>    r[<span class="hljs-number">0</span>] = q.front().priority - <span class="hljs-number">10001</span>, i--<br>    <span class="hljs-keyword">while</span> (++i &lt; nums.length) &#123;<br>        q.enqueue(i, nums[i] + <span class="hljs-number">10001</span>)<br>        <span class="hljs-keyword">while</span> (q.front().element &lt;= i - k) q.dequeue()<br>        r[i - k + <span class="hljs-number">1</span>] = q.front().priority - <span class="hljs-number">10001</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/sliding-window-maximum/solution/ji-shu-shuang-duan-fen-kuai-you-xian-5xi-87ud/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="4-2-MyMaxPriorityQueue"><a href="#4-2-MyMaxPriorityQueue" class="headerlink" title="4.2 MyMaxPriorityQueue"></a>4.2 MyMaxPriorityQueue</h5><p>完全二叉树封装的JS大根堆优先队列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxSlidingWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = <span class="hljs-keyword">new</span> MyMaxPriorityQueue, r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(nums.length - k + <span class="hljs-number">1</span>), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; k) q.add(nums[i], i)<br>    r[<span class="hljs-number">0</span>] = q.first().v, i--<br>    <span class="hljs-keyword">while</span> (++i &lt; nums.length) &#123;<br>        q.add(nums[i], i)<br>        <span class="hljs-keyword">while</span> (q.first().second &lt;= i - k) q.shift()<br>        r[i - k + <span class="hljs-number">1</span>] = q.first().v<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMaxPriorityQueue</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">a</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.q = []<br>        a &amp;&amp; <span class="hljs-built_in">this</span>._build(a)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">v, second</span>)</span> &#123; <span class="hljs-comment">// 添加</span><br>        <span class="hljs-built_in">this</span>.q.push(&#123;v, second&#125;) <span class="hljs-comment">// 添加 值（比较用） 和 第二参数（索引）</span><br>        <span class="hljs-built_in">this</span>._up(<span class="hljs-built_in">this</span>.q.length - <span class="hljs-number">1</span>) <span class="hljs-comment">// 放入 二叉树的尾部，然后 上浮</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">shift</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 弹出</span><br>        <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">this</span>.q.shift() <span class="hljs-comment">// 弹出 根节点</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.q.length) &#123; <span class="hljs-comment">// 如果还有节点</span><br>            <span class="hljs-built_in">this</span>.q.unshift(<span class="hljs-built_in">this</span>.q.pop()) <span class="hljs-comment">// 将 最尾部的节点 放到根节点位置</span><br>            <span class="hljs-built_in">this</span>._down(<span class="hljs-number">0</span>) <span class="hljs-comment">// 下沉 根节点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">first</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 根节点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.q[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">length</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 优先队列长度</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.q.length<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">_build</span>(<span class="hljs-params">a</span>)</span> &#123; <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-built_in">this</span>.q.push(&#123;<span class="hljs-attr">v</span>:a[<span class="hljs-number">0</span>]&#125;) <span class="hljs-comment">// 先给空队列放入第0个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++) <span class="hljs-built_in">this</span>.q.unshift(&#123;<span class="hljs-attr">v</span>:a[i]&#125;), <span class="hljs-built_in">this</span>._down(<span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 从第1个元素起，把新元素放在根节点，然后下沉 根节点</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">_swap</span>(<span class="hljs-params">l, r, t</span>)</span> &#123; <span class="hljs-comment">// 交换</span><br>        t = <span class="hljs-built_in">this</span>.q[l], <span class="hljs-built_in">this</span>.q[l] = <span class="hljs-built_in">this</span>.q[r], <span class="hljs-built_in">this</span>.q[r] = t <span class="hljs-comment">// 交换两个节点</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">_down</span>(<span class="hljs-params">i</span>)</span>&#123; <span class="hljs-comment">// 下沉</span><br>        <span class="hljs-keyword">var</span> t = <span class="hljs-built_in">this</span>.q.length - <span class="hljs-number">2</span> &gt;&gt; <span class="hljs-number">1</span>, max, maxI <span class="hljs-comment">// 叶子节点的根节点索引，下沉到 叶子节点的根节点停止</span><br>        <span class="hljs-keyword">while</span>(i &lt;= t)&#123;<br>            <span class="hljs-keyword">var</span> l = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, r = l + <span class="hljs-number">1</span> <span class="hljs-comment">// 左子节点的索引 = 当前节点索引 * 2 + 1，右子节点的索引 = 左子节点的索引 + 1</span><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">this</span>.q[l] ? <span class="hljs-built_in">this</span>.q[l].v : -<span class="hljs-literal">Infinity</span>) &gt;= (<span class="hljs-built_in">this</span>.q[r] ? <span class="hljs-built_in">this</span>.q[r].v : -<span class="hljs-literal">Infinity</span>))<br>                 max = <span class="hljs-built_in">this</span>.q[l].v, maxI = l<br>            <span class="hljs-keyword">else</span> max = <span class="hljs-built_in">this</span>.q[r].v, maxI = r <span class="hljs-comment">// 找到 左子节点 和 右子节点的 较大者</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.q[i].v &lt; max) <span class="hljs-built_in">this</span>._swap(i, maxI), i = maxI <span class="hljs-comment">// 当前节点的 左子节点 或 右子节点 比 它大，交换 </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">_up</span>(<span class="hljs-params">i</span>)</span> &#123; <span class="hljs-comment">// 上浮</span><br>        <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 不能超过根节点</span><br>            <span class="hljs-keyword">var</span> t = i - <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span> <span class="hljs-comment">// 当前节点的 根节点索引 = 当前节点索引 - 1 的一半</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.q[i].v &gt;= <span class="hljs-built_in">this</span>.q[t].v) <span class="hljs-built_in">this</span>._swap(i, t), i = t <span class="hljs-comment">// 当前节点值 比 它的根节点 大，交换</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/sliding-window-maximum/solution/ji-shu-shuang-duan-fen-kuai-you-xian-5xi-87ud/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数</tag>
      
      <tag>双端</tag>
      
      <tag>分块</tag>
      
      <tag>优先</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣605 种花问题</title>
    <link href="/2021/01/01/%E5%8A%9B%E6%89%A3605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2021/01/01/%E5%8A%9B%E6%89%A3605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。</p><p> </p><p>示例 1：<br>输入：flowerbed = [1,0,0,0,1], n = 1<br>输出：true</p><p>示例 2：<br>输入：flowerbed = [1,0,0,0,1], n = 2<br>输出：false </p><p>提示：</p><p>1 &lt;= flowerbed.length &lt;= 2 * 104<br>flowerbed[i] 为 0 或 1<br>flowerbed 中不存在相邻的两朵花<br>0 &lt;= n &lt;= flowerbed.length</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/can-place-flowers">https://leetcode-cn.com/problems/can-place-flowers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-正则"><a href="#一-正则" class="headerlink" title="一 正则"></a>一 正则</h4><p>数组转字符串，分6种情况一次匹配出所有可种花位置。本文拓展中将详解每种情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> canPlaceFlowers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flowerbed, n</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(flowerbed.join(<span class="hljs-string">&#x27;&#x27;</span>).matchAll(<span class="hljs-regexp">/(^0(?=00)|^00|00$|00(?=00)|000|^0$)/g</span>)).length &gt;= n <br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/can-place-flowers/solution/zheng-ze-sao-miao-tan-xin-1xing-dai-ma-3-e6p8/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-扫描"><a href="#二-扫描" class="headerlink" title="二 扫描"></a>二 扫描</h4><p>遍历，找 前（最前为undefined） + 当前 + 后（最后为undefined） 都不为1的位置<br>找到后，不真正种花flowerbed[i] = 1。下个位置一定不能种，直接i++即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> canPlaceFlowers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flowerbed, n</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; flowerbed.length; i++) <br>        <span class="hljs-keyword">if</span> (flowerbed[i - <span class="hljs-number">1</span>] !== <span class="hljs-number">1</span> &amp;&amp; flowerbed[i] !== <span class="hljs-number">1</span> &amp;&amp; flowerbed[i + <span class="hljs-number">1</span>] !== <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (--n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            i++<br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/can-place-flowers/solution/zheng-ze-sao-miao-tan-xin-1xing-dai-ma-3-e6p8/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="三-贪心"><a href="#三-贪心" class="headerlink" title="三 贪心"></a>三 贪心</h4><p>遍历，最多经历无花 开始 → 花 花 → 花 花 → 结束4种情况<br>上一有花索引 当前索引与种花数量的关系如图<br>[url=<a href="https://imgchr.com/i/sS5M1f][img]https://s3.ax1x.com/2021/01/02/sS5M1f.md.png[/img][/url]">https://imgchr.com/i/sS5M1f][img]https://s3.ax1x.com/2021/01/02/sS5M1f.md.png[/img][/url]</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> canPlaceFlowers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flowerbed, n</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>, p = -<span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>, l = flowerbed.length - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; l) <br>        <span class="hljs-keyword">if</span> (flowerbed[i] === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (p === -<span class="hljs-number">1</span>)  <span class="hljs-comment">// 开始 → 花</span><br>                r = i - <span class="hljs-number">0</span> &gt;&gt; <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">// 花 → 花</span><br>                r += i - p - <span class="hljs-number">2</span> &gt;&gt; <span class="hljs-number">1</span><br>            p = i<br>            <span class="hljs-keyword">if</span> (r &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>    <span class="hljs-keyword">if</span> (p === -<span class="hljs-number">1</span>)  <span class="hljs-comment">// 无花</span><br>        r = l - <span class="hljs-number">0</span> + <span class="hljs-number">2</span> &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 花 → 结束</span><br>        r += l - p &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> r &gt;= n<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/can-place-flowers/solution/zheng-ze-sao-miao-tan-xin-1xing-dai-ma-3-e6p8/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="四-贪心-·-优化"><a href="#四-贪心-·-优化" class="headerlink" title="四 贪心 · 优化"></a>四 贪心 · 优化</h4><p>原数组前后，即-2位和length + 1位种花 → 1 0 原数组 0 1<br>既不影响结果，又将贪心经历的情况减少为一种 花 → 花</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> canPlaceFlowers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flowerbed, n</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> p = -<span class="hljs-number">2</span>, i = -<span class="hljs-number">1</span>, r = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (++i &lt; flowerbed.length)<br>        <span class="hljs-keyword">if</span> (flowerbed[i]) &#123;<br>            <span class="hljs-keyword">if</span> ((r += (i - p - <span class="hljs-number">2</span>) &gt;&gt; <span class="hljs-number">1</span>) &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            p = i<br>        &#125;<br>    r += (i + <span class="hljs-number">1</span> - p - <span class="hljs-number">2</span>) &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> r &gt;= n<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/can-place-flowers/solution/zheng-ze-sao-miao-tan-xin-1xing-dai-ma-3-e6p8/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>正则概述<br>1940年，Warren McCulloch与Walter Pitts将神经系统中的神经元描述成小而简单的自动控制元<br>1950年，数学家Stephen Kleene利用称之为“正则集合”的数学符号来描述此模型<br>随后，Ken Thompson将此符号系统引入编辑器QED，成为Unix上的编辑器ed，最终引入grep<br>此后，正则表达式被广泛应用于各种 Unix 或类 Unix 系统工具中，POSIX规范正则表达式出现<br>1986年1月19日，Perl正则表达式发布<br>1997年夏天，Philip Hazel开始用C语言编写PCRE，后被多种编程语言、服务器环境集成</p><p>PCRE，即Perl 兼容正则表达式，Perl Compatible Regular Expressions，强大而灵活<br>JavaScript部分实现了PCRE<br>分组，匹配（贪婪，惰性），引用（反），捕获，正向前瞻，负向前瞻，正向后顾，负向后顾等  </p><p>正则解题  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/(^0(?=00)|^00|00$|00(?=00)|000|^0$)/g</span>匹配所有可种<span class="hljs-number">1</span>花的位置区间 <br> <br>只要有连续<span class="hljs-number">3</span>个<span class="hljs-number">0</span>，至少可种<span class="hljs-number">1</span>花。能不能种<span class="hljs-number">2</span>花，要看左侧和右侧情况  <br><span class="hljs-regexp">/000/</span> 要看其它情况，优先级较低 <br>[<span class="hljs-number">0</span>] 只有<span class="hljs-number">1</span>个<span class="hljs-number">0</span>，只能种<span class="hljs-number">1</span>花  <br><span class="hljs-regexp">/^0$/</span>　^开始位置，$结束位置。特殊情况，优先级最低  <br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>] [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>] 开始位置起<span class="hljs-number">2</span>个<span class="hljs-number">0</span>，无论第<span class="hljs-number">3</span>个是<span class="hljs-number">0</span>还是<span class="hljs-number">1</span>，开始位置一定种<span class="hljs-number">1</span>花  <br><span class="hljs-regexp">/^00/</span>  <br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>] [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>] 结束位置前<span class="hljs-number">2</span>个<span class="hljs-number">0</span>，无论倒数第<span class="hljs-number">3</span>个是<span class="hljs-number">0</span>还是<span class="hljs-number">1</span>，结束位置一定种<span class="hljs-number">1</span>花  <br><span class="hljs-regexp">/00$/</span>  <br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>] 开始位置起<span class="hljs-number">3</span>个<span class="hljs-number">0</span>，如果被<span class="hljs-regexp">/000/</span>匹配，只能种<span class="hljs-number">1</span>花。应[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]这样种 <br><span class="hljs-regexp">/^0(?=00)/</span>　?=正向前瞻，匹配后面有<span class="hljs-number">2</span>个<span class="hljs-number">0</span>的<span class="hljs-number">0</span>  <br>匹配到第<span class="hljs-number">1</span>个<span class="hljs-number">0</span>种花，后面<span class="hljs-number">2</span>个<span class="hljs-number">0</span>交给<span class="hljs-regexp">/00$/</span>匹配种花 <br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>] 开始位置起，<span class="hljs-number">5</span>个<span class="hljs-number">0</span>，如果被上面的<span class="hljs-number">5</span>和<span class="hljs-number">1</span>匹配，结果<span class="hljs-number">0</span> <span class="hljs-number">000</span>，剩<span class="hljs-number">1</span>个<span class="hljs-number">0</span> <br><span class="hljs-regexp">/00(?=00)/</span>　?=正向前瞻，匹配后面有<span class="hljs-number">2</span>个<span class="hljs-number">0</span>的<span class="hljs-number">00</span>  <br>匹配到第<span class="hljs-number">1</span>个<span class="hljs-number">0</span>种花，后面<span class="hljs-number">2</span>个<span class="hljs-number">0</span>被<span class="hljs-regexp">/00(?=00)/</span>匹配种花，剩下<span class="hljs-number">2</span>个<span class="hljs-number">0</span>被<span class="hljs-regexp">/00$/</span>匹配种花  <br>以上正则表达式优先级：匹配个数 小 → 大。个数相同，条件宽泛的放后。特殊情况最后  <br></code></pre></td></tr></table></figure><p>matchAlll<br>区别于match，使用matchAll传入正则时，修饰符flag一定要为g全局<br>即使结果为null，matchAll也会返回RegExpStringIterator。用Array.from转数组获取长度<br>新版Chrome中，该对象可以直接forEach，返回每个匹配位置的值，索引和捕获<br>在不支持forEach的运行环境里，可以用.next迭代地访问每个匹配<br>这里用matchAll找到所有1的索引，重写本题的贪心解法 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> canPlaceFlowers = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flowerbed, n</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> p = -<span class="hljs-number">1</span>, r = <span class="hljs-number">0</span>, l = flowerbed.length - <span class="hljs-number">1</span>, v<br>    <span class="hljs-keyword">const</span> i = flowerbed.join(<span class="hljs-string">&#x27;&#x27;</span>).matchAll(<span class="hljs-regexp">/1/g</span>)<br>    <span class="hljs-keyword">while</span> (v = i.next().value) &#123;<br>        <span class="hljs-keyword">if</span> (p === -<span class="hljs-number">1</span>)  <span class="hljs-comment">// 开始 → 花</span><br>            r = v.index - <span class="hljs-number">0</span> &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 花 → 花</span><br>            r += v.index - p - <span class="hljs-number">2</span> &gt;&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> (r &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        p = v.index<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p === -<span class="hljs-number">1</span>) <span class="hljs-comment">// 无花</span><br>        r = l - <span class="hljs-number">0</span> + <span class="hljs-number">2</span> &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 花 → 结束</span><br>        r += l - p &gt;&gt; <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> r &gt;= n<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/can-place-flowers/solution/zheng-ze-sao-miao-tan-xin-1xing-dai-ma-3-e6p8/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
      <tag>正则</tag>
      
      <tag>扫描</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣435 无重叠区间</title>
    <link href="/2020/12/31/%E5%8A%9B%E6%89%A3435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/"/>
    <url>/2020/12/31/%E5%8A%9B%E6%89%A3435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例 1:<br>输入: [ [1,2], [2,3], [3,4], [1,3] ]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p><p>示例 2:<br>输入: [ [1,2], [1,2], [1,2] ]<br>输出: 2<br>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p><p>示例 3:<br>输入: [ [1,2], [2,3] ]<br>输出: 0<br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/non-overlapping-intervals">https://leetcode-cn.com/problems/non-overlapping-intervals</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-贪心算法"><a href="#一-贪心算法" class="headerlink" title="一 贪心算法"></a>一 贪心算法</h4><h5 id="1-1-按结束升序"><a href="#1-1-按结束升序" class="headerlink" title="1.1 按结束升序"></a>1.1 按结束升序</h5><p>图示加[2,3]比[2,4]好。目标：不重复 且 结束小 的区间</p><p>结束小：按结束升序，遍历先遇到的结束小。结束相同，谁在前一样<br>不重复：r最后不重复区间的结束。遇 开始 &gt; r，即不重复，更新r，找到目标次数+1<br><a href="https://imgchr.com/i/sS4lw9"><img src="https://s3.ax1x.com/2021/01/02/sS4lw9.png" alt="sS4lw9.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript">找不重复区间<br><span class="hljs-keyword">var</span> eraseOverlapIntervals = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">intervals</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> n = intervals.length<br>    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    intervals.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">let</span> r = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], count = <span class="hljs-number">1</span>, i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(++i &lt; n)<br>        <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= r) &#123;<br>            count++<br>            r = intervals[i][<span class="hljs-number">1</span>]<br>        &#125; <span class="hljs-comment">// else &#123; 重复区间数++ &#125;</span><br>    <span class="hljs-keyword">return</span> n - count<br>&#125;;<br><br><br><br><br>找重复区间：找不重复的区间<span class="hljs-keyword">else</span>即重复的<br><span class="hljs-keyword">var</span> eraseOverlapIntervals = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">intervals</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> n = intervals.length<br>    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    intervals.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">let</span> r = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], res = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(++i &lt; n) intervals[i][<span class="hljs-number">0</span>] &gt;= r ? r = intervals[i][<span class="hljs-number">1</span>] : res++<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/non-overlapping-intervals/solution/tan-xin-dong-tai-gui-hua-er-fen-cha-zhao-enic/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="1-2-按开始升序"><a href="#1-2-按开始升序" class="headerlink" title="1.2 按开始升序"></a>1.2 按开始升序</h5><p>图示加[2,3]比[2,4]好。目标：重复 且 开始小 的区间</p><p>开始小：按开始升序，遍历先遇到的开始小。开始相同，谁在前一样<br>重复：r最后不重复区间的结束<br>遇到 开始 &gt;= r，即不重复，更新r<br>遇到 开始 &lt; r，即重复，找到目标次数+1<br>结束 = r，留谁都行，留r，r不变<br>结束 &gt; r，留结束为r的区间（删当前区间），r不变<br>结束 &lt; r，留当前区间（删r，即结束大区间），更新r</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eraseOverlapIntervals = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">intervals</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> n = intervals.length<br>    <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    intervals.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">let</span> r = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], res = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(++i &lt; n)<br>        <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &lt; r) &#123;<br>            res++<br>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">1</span>] &lt; r) r = intervals[i][<span class="hljs-number">1</span>]<br>        &#125; <span class="hljs-keyword">else</span> r = intervals[i][<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/non-overlapping-intervals/solution/tan-xin-dong-tai-gui-hua-er-fen-cha-zhao-enic/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-动态规划"><a href="#二-动态规划" class="headerlink" title="二 动态规划"></a>二 动态规划</h4><h5 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h5><p>遍历，枚举开始或结束在 当前区间 前的 区间，目标：不重复</p><p>开始 或 结束 在当前区间前：按开始或结束升序，先遇到在前的<br>不重复：被枚举区间结束 &lt;= 当前区间开始<br>dp[i]代表j ∈ [0, i]不重复区间个数 = max(dp[i], dp[j] + 1)<br><a href="https://imgchr.com/i/sS4Ikn"><img src="https://s3.ax1x.com/2021/01/02/sS4Ikn.png" alt="sS4Ikn.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">按结束升序<br><span class="hljs-keyword">var</span> eraseOverlapIntervals = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">intervals</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> l = intervals.length, dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(l).fill(<span class="hljs-number">1</span>)<br>    intervals.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; l; i++) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>            <span class="hljs-keyword">if</span> (intervals[j][<span class="hljs-number">1</span>] &lt;= intervals[i][<span class="hljs-number">0</span>])<br>                dp[i] = <span class="hljs-built_in">Math</span>.max(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span> <span class="hljs-comment">// 按结束升序，被枚举区间的结束也升序，后面更大，可终止循环</span><br>    <span class="hljs-keyword">return</span> l ? l - <span class="hljs-built_in">Math</span>.max(...dp) : <span class="hljs-number">0</span><br>&#125;;<br><br><br><br><br>按开始升序<br><span class="hljs-keyword">var</span> eraseOverlapIntervals = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">intervals</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> l = intervals.length, dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(l).fill(<span class="hljs-number">1</span>)<br>    intervals.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; l; i++) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>            <span class="hljs-keyword">if</span> (intervals[j][<span class="hljs-number">1</span>] &lt;= intervals[i][<span class="hljs-number">0</span>])<br>                dp[i] = <span class="hljs-built_in">Math</span>.max(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> l ? l - <span class="hljs-built_in">Math</span>.max(...dp) : <span class="hljs-number">0</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/non-overlapping-intervals/solution/tan-xin-dong-tai-gui-hua-er-fen-cha-zhao-enic/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="2-2-二分查找"><a href="#2-2-二分查找" class="headerlink" title="2.2 二分查找"></a>2.2 二分查找</h5><p>按结束升序时，被枚举区间的结束也升序<br>被枚举区间中，二分查找最后一个结束&lt;=开始的区间索引，递减向前更新dp即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> eraseOverlapIntervals = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">intervals</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> n = intervals.length, dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(n).fill(<span class="hljs-number">1</span>)<br>    intervals.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>, r = i<br>        <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>            <span class="hljs-keyword">const</span> m = (l + r) &gt;&gt; <span class="hljs-number">1</span><br>            intervals[m][<span class="hljs-number">1</span>] &lt;= intervals[i][<span class="hljs-number">0</span>] ? l = m + <span class="hljs-number">1</span> : r = m<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l--) dp[i] = <span class="hljs-built_in">Math</span>.max(dp[i], dp[l] + <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> n ? n - <span class="hljs-built_in">Math</span>.max(...dp) : <span class="hljs-number">0</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/non-overlapping-intervals/solution/tan-xin-dong-tai-gui-hua-er-fen-cha-zhao-enic/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣1046 最后一块石头的重量</title>
    <link href="/2020/12/30/%E5%8A%9B%E6%89%A31046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/"/>
    <url>/2020/12/30/%E5%8A%9B%E6%89%A31046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><p>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。  </p><p> </p><p>示例：<br>输入：[2,7,4,1,8,1]<br>输出：1<br>解释：<br>先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，<br>再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，<br>接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，<br>最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。 </p><p>提示：</p><p>1 &lt;= stones.length &lt;= 30<br>1 &lt;= stones[i] &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/last-stone-weight">https://leetcode-cn.com/problems/last-stone-weight</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">stones</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> lastStoneWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stones</span>) </span>&#123;<br>    <span class="hljs-keyword">while</span>(stones.length&gt;<span class="hljs-number">1</span>)&#123;<br>        stones.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span> b-a);<br>        <span class="hljs-keyword">if</span>(stones[<span class="hljs-number">0</span>]!==stones[<span class="hljs-number">1</span>])&#123;<br>            stones.push(stones[<span class="hljs-number">0</span>]-stones[<span class="hljs-number">1</span>]);<br>        &#125;<br>        stones.shift();<br>        stones.shift();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(stones.length===<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> stones[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-递归"><a href="#一-递归" class="headerlink" title="一 递归"></a>一 递归</h4><h5 id="1-1-Sort"><a href="#1-1-Sort" class="headerlink" title="1.1 Sort"></a>1.1 Sort</h5><p>解题思路<br>升序，取后两个 或 降序，取前两个。不同差放数组，递归直至边界数组长度 &lt;= 1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">升序<br><span class="hljs-keyword">var</span> lastStoneWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stones</span>) </span>&#123;<br>    stones.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)<br>    <span class="hljs-keyword">if</span> (stones.length &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">const</span> d = stones.pop() - stones.pop()<br>        <span class="hljs-keyword">if</span> (d) stones.push(d)<br>        <span class="hljs-keyword">return</span> lastStoneWeight(stones)<br>    &#125;<br>    <span class="hljs-keyword">return</span> stones.length ? stones[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span><br>&#125;;<br><br><br><span class="hljs-number">1</span>行代码：边界，即 递归终止条件 前置：<br><span class="hljs-keyword">var</span> lastStoneWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stones, d</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> stones.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b).length &lt;= <span class="hljs-number">1</span> ? stones[<span class="hljs-number">0</span>] || <span class="hljs-number">0</span> :<br>           ((d = stones.pop() - stones.pop()) &amp;&amp; stones.push(d), lastStoneWeight(stones))<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/last-stone-weight/solution/di-gui-die-dai-dui-lie-cha-pai-1xing-dai-70hv/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="1-2-插入排序"><a href="#1-2-插入排序" class="headerlink" title="1.2 插入排序"></a>1.2 插入排序</h5><p>解题思路<br>数组已有序，放差时，把差交换到插入位置即可。splice插入也可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">升序<br><br><br><span class="hljs-keyword">var</span> lastStoneWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stones, d</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> sort(stones).length &lt;= <span class="hljs-number">1</span> ? stones[<span class="hljs-number">0</span>] || <span class="hljs-number">0</span> :<br>           ((d = stones.pop() - stones.pop()) &amp;&amp; stones.push(d), lastStoneWeight(stones))<br>&#125;;<br><span class="hljs-keyword">var</span> sort = <span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j-- &amp;&amp; a[j + <span class="hljs-number">1</span>] &lt; a[j];)<br>            [a[j], a[j + <span class="hljs-number">1</span>]] = [a[j + <span class="hljs-number">1</span>], a[j]]<br>    <span class="hljs-keyword">return</span> a <br>&#125;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/last-stone-weight/solution/di-gui-die-dai-dui-lie-cha-pai-1xing-dai-70hv/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-迭代"><a href="#二-迭代" class="headerlink" title="二 迭代"></a>二 迭代</h4><h5 id="2-1-Sort"><a href="#2-1-Sort" class="headerlink" title="2.1 Sort"></a>2.1 Sort</h5><p>解题思路<br>递归边界 取反 即 迭代条件：数组长度 &gt; 1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">升序<br><br><br><span class="hljs-keyword">var</span> lastStoneWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stones</span>) </span>&#123;<br>    sort(stones)<br>    <span class="hljs-keyword">while</span> (stones.length &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">const</span> d = stones.pop() - stones.pop()<br>        <span class="hljs-keyword">if</span> (d) &#123; <br>            stones.push(d)<br>            sort(stones)<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> stones.length ? stones[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span><br>&#125;;<br><span class="hljs-keyword">var</span> sort = <span class="hljs-function"><span class="hljs-params">stones</span> =&gt;</span> stones.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/last-stone-weight/solution/di-gui-die-dai-dui-lie-cha-pai-1xing-dai-70hv/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="2-2-插入排序"><a href="#2-2-插入排序" class="headerlink" title="2.2 插入排序"></a>2.2 插入排序</h5><p>解题思路<br>迭代不需额外变量，可区分初次排序和对差排序。前者Sort自动优化，后者插入排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript">升序 + Sort<br><br><br><span class="hljs-keyword">var</span> lastStoneWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stones</span>) </span>&#123;<br>    stones.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)<br>    <span class="hljs-keyword">while</span> (stones.length &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">let</span> d = stones.pop() - stones.pop(), i = stones.length, t<br>        <span class="hljs-keyword">if</span> (d) &#123;<br>            stones.push(d)<br>            <span class="hljs-keyword">while</span>(stones[i - <span class="hljs-number">1</span>] &gt; stones[i]) &#123;<br>                t = stones[i - <span class="hljs-number">1</span>]<br>                stones[i - <span class="hljs-number">1</span>] = stones[i]<br>                stones[i] = t<br>                i--<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stones.length ? stones[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span><br>&#125;;<br><br><br><br><br>升序 · 插入排序：<br><span class="hljs-keyword">var</span> lastStoneWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stones</span>) </span>&#123;<br>    sort(stones)<br>    <span class="hljs-keyword">while</span> (stones.length &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">let</span> d = stones.pop() - stones.pop()<br>        <span class="hljs-keyword">if</span> (d) &#123;<br>            stones.push(d)<br>            sort(stones)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stones.length ? stones[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span><br>&#125;;<br><span class="hljs-keyword">var</span> sort = <span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j-- &amp;&amp; a[j + <span class="hljs-number">1</span>] &lt; a[j];)<br>            [a[j], a[j + <span class="hljs-number">1</span>]] = [a[j + <span class="hljs-number">1</span>], a[j]]<br>    <span class="hljs-keyword">return</span> a <br>&#125;<br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/last-stone-weight/solution/di-gui-die-dai-dui-lie-cha-pai-1xing-dai-70hv/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="三-优先队列"><a href="#三-优先队列" class="headerlink" title="三 优先队列"></a>三 优先队列</h4><h5 id="3-1-大根堆-·-MaxPriorityQueue"><a href="#3-1-大根堆-·-MaxPriorityQueue" class="headerlink" title="3.1 大根堆 · MaxPriorityQueue"></a>3.1 大根堆 · MaxPriorityQueue</h5><p>解题思路<br>大根堆优先队列，弹出两个比较。不同差放队列，迭代或递归重复直至数组长度&lt;=1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">递归：MaxPriorityQueue是力扣封装好的JS大根堆优先队列<br><span class="hljs-keyword">var</span> lastStoneWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stones</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = <span class="hljs-keyword">new</span> MaxPriorityQueue(), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; stones.length) q.enqueue(<span class="hljs-string">&#x27;&#x27;</span>, stones[i])<br>    f = <span class="hljs-function"><span class="hljs-params">q</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (q.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> (q.size() === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> q.front().priority<br>        <span class="hljs-keyword">const</span> d = q.dequeue().priority - q.dequeue().priority<br>        <span class="hljs-keyword">if</span> (d) q.enqueue(<span class="hljs-string">&#x27;&#x27;</span>, d) <br>        <span class="hljs-keyword">return</span> f(q)<br>    &#125;<br>    <span class="hljs-keyword">return</span> f(q)<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/last-stone-weight/solution/di-gui-die-dai-dui-lie-cha-pai-1xing-dai-70hv/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>3.2 大根堆 · 完全二叉树<br>解题思路<br>基于数组索引和完全二叉树节点对应关系，在JS层封装一个基于大根堆的优先队列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMaxPriorityQueue</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">a</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.q = []<br>        a &amp;&amp; <span class="hljs-built_in">this</span>._build(a)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">v, second</span>)</span> &#123; <span class="hljs-comment">// 添加</span><br>        <span class="hljs-built_in">this</span>.q.push(&#123;v, second&#125;) <span class="hljs-comment">// 添加 值（比较用） 和 第二参数（索引）</span><br>        <span class="hljs-built_in">this</span>._up(<span class="hljs-built_in">this</span>.q.length - <span class="hljs-number">1</span>) <span class="hljs-comment">// 放入 二叉树的尾部，然后 上浮</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">shift</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 弹出</span><br>        <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">this</span>.q.shift() <span class="hljs-comment">// 弹出 根节点</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.q.length) &#123; <span class="hljs-comment">// 如果还有节点</span><br>            <span class="hljs-built_in">this</span>.q.unshift(<span class="hljs-built_in">this</span>.q.pop()) <span class="hljs-comment">// 将 最尾部的节点 放到根节点位置</span><br>            <span class="hljs-built_in">this</span>._down(<span class="hljs-number">0</span>) <span class="hljs-comment">// 下沉 根节点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">first</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 根节点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.q[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">length</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 优先队列长度</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.q.length<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">_build</span>(<span class="hljs-params">a</span>)</span> &#123; <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-built_in">this</span>.q.push(&#123;<span class="hljs-attr">v</span>:a[<span class="hljs-number">0</span>]&#125;) <span class="hljs-comment">// 先给空队列放入第0个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++) <span class="hljs-built_in">this</span>.q.unshift(&#123;<span class="hljs-attr">v</span>:a[i]&#125;), <span class="hljs-built_in">this</span>._down(<span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 从第1个元素起，把新元素放在根节点，然后下沉 根节点</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">_swap</span>(<span class="hljs-params">l, r, t</span>)</span> &#123; <span class="hljs-comment">// 交换</span><br>        t = <span class="hljs-built_in">this</span>.q[l], <span class="hljs-built_in">this</span>.q[l] = <span class="hljs-built_in">this</span>.q[r], <span class="hljs-built_in">this</span>.q[r] = t <span class="hljs-comment">// 交换两个节点</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">_down</span>(<span class="hljs-params">i</span>)</span>&#123; <span class="hljs-comment">// 下沉</span><br>        <span class="hljs-keyword">var</span> t = <span class="hljs-built_in">this</span>.q.length - <span class="hljs-number">2</span> &gt;&gt; <span class="hljs-number">1</span>, max, maxI <span class="hljs-comment">// 叶子节点的根节点索引，下沉到 叶子节点的根节点停止</span><br>        <span class="hljs-keyword">while</span>(i &lt;= t)&#123;<br>            <span class="hljs-keyword">var</span> l = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, r = l + <span class="hljs-number">1</span> <span class="hljs-comment">// 左子节点的索引 = 当前节点索引 * 2 + 1，右子节点的索引 = 左子节点的索引 + 1</span><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">this</span>.q[l] ? <span class="hljs-built_in">this</span>.q[l].v : -<span class="hljs-literal">Infinity</span>) &gt;= (<span class="hljs-built_in">this</span>.q[r] ? <span class="hljs-built_in">this</span>.q[r].v : -<span class="hljs-literal">Infinity</span>))<br>                 max = <span class="hljs-built_in">this</span>.q[l].v, maxI = l<br>            <span class="hljs-keyword">else</span> max = <span class="hljs-built_in">this</span>.q[r].v, maxI = r <span class="hljs-comment">// 找到 左子节点 和 右子节点的 较大者</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.q[i].v &lt; max) <span class="hljs-built_in">this</span>._swap(i, maxI), i = maxI <span class="hljs-comment">// 当前节点的 左子节点 或 右子节点 比 它大，交换 </span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">_up</span>(<span class="hljs-params">i</span>)</span> &#123; <span class="hljs-comment">// 上浮</span><br>        <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 不能超过根节点</span><br>            <span class="hljs-keyword">var</span> t = i - <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span> <span class="hljs-comment">// 当前节点的 根节点索引 = 当前节点索引 - 1 的一半</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.q[i].v &gt;= <span class="hljs-built_in">this</span>.q[t].v) <span class="hljs-built_in">this</span>._swap(i, t), i = t <span class="hljs-comment">// 当前节点值 比 它的根节点 大，交换</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><br><br><br><br>递归<br><span class="hljs-keyword">var</span> lastStoneWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stones</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = <span class="hljs-keyword">new</span> MyMaxPriorityQueue(), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; stones.length) q.add(stones[i])<br>    f = <span class="hljs-function"><span class="hljs-params">q</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (q.length() === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> (q.length() === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> q.first().v<br>        <span class="hljs-keyword">const</span> d = q.shift().v - q.shift().v<br>        <span class="hljs-keyword">if</span> (d) q.add(d)<br>        <span class="hljs-keyword">return</span> f(q)<br>    &#125;<br>    <span class="hljs-keyword">return</span> f(q)<br>&#125;;<br><br><br>迭代<br><span class="hljs-keyword">var</span> lastStoneWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stones</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = <span class="hljs-keyword">new</span> MyMaxPriorityQueue(), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; stones.length) q.add(stones[i])<br>    <span class="hljs-keyword">while</span> (q.length() &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">const</span> d = q.shift().v - q.shift().v<br>        <span class="hljs-keyword">if</span> (d) q.add(d)<br>    &#125;<br>    <span class="hljs-keyword">return</span> q.length() ? q.first().v : <span class="hljs-number">0</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/last-stone-weight/solution/di-gui-die-dai-dui-lie-cha-pai-1xing-dai-70hv/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="四-计数排序"><a href="#四-计数排序" class="headerlink" title="四 计数排序"></a>四 计数排序</h4><p>解题思路<br>来自《非排序法》。本题输入数组长度&lt;=1000<br>用长度1000数组，以数为索引，统计数出现次数，每轮倒序遍历，即 从大到小找<br>先找最大数y。遇出现次数=1，y = 索引<br>遇出现次数&gt;=2，y和第二大数x相同 = 索引，停止循环<br>再找第二大数x。y总是先找到，再找到出现次数不为0，索引就是x<br>直到找不到x（数组只剩1个或没有），停止循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javascript">递归<br><span class="hljs-keyword">var</span> lastStoneWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stones</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">1000</span>), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; stones.length) h[stones[i]]++<br>    f = <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">for</span>(i = h.length, x = y = <span class="hljs-number">0</span>; i--;) &#123;<br>            <span class="hljs-keyword">if</span> (h[i] === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span><br>            h[i]--<br>            <span class="hljs-keyword">if</span> (y) &#123;<br>                x = i<br>                <span class="hljs-keyword">break</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (h[i] &gt;= <span class="hljs-number">1</span>) &#123;<br>                    y = x = i<br>                    h[i]--<br>                    <span class="hljs-keyword">break</span><br>                &#125; <span class="hljs-keyword">else</span> y = i<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (y &gt; x) h[y - x]++<br>        <span class="hljs-keyword">return</span> x ? f(h) : y || <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> f(h)<br>&#125;;<br><br><br><br><br>迭代<br><span class="hljs-keyword">var</span> lastStoneWeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stones</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">1000</span>), i = -<span class="hljs-number">1</span>, x, y<br>    <span class="hljs-keyword">while</span>(++i &lt; stones.length) h[stones[i]]++<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">for</span>(i = h.length, x = y = <span class="hljs-number">0</span>; i--;) &#123;<br>            <span class="hljs-keyword">if</span> (h[i] === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span><br>            h[i]--<br>            <span class="hljs-keyword">if</span> (y) &#123;<br>                x = i<br>                <span class="hljs-keyword">break</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (h[i] &gt;= <span class="hljs-number">1</span>) &#123;<br>                    y = x = i<br>                    h[i]--<br>                    <span class="hljs-keyword">break</span><br>                &#125; <span class="hljs-keyword">else</span> y = i<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (y &gt; x) h[y - x]++<br>    &#125; <span class="hljs-keyword">while</span> (x)<br>    <span class="hljs-keyword">return</span> y || <span class="hljs-number">0</span><br>&#125;;<br><br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/last-stone-weight/solution/di-gui-die-dai-dui-lie-cha-pai-1xing-dai-70hv/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>迭代</tag>
      
      <tag>队列</tag>
      
      <tag>插排</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣330 按要求补齐数组</title>
    <link href="/2020/12/29/%E5%8A%9B%E6%89%A3330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2020/12/29/%E5%8A%9B%E6%89%A3330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><p>示例 1:<br>输入: nums = [1,3], n = 6<br>输出: 1<br>解释:<br>根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。<br>现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。<br>其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。<br>所以我们最少需要添加一个数字。</p><p>示例 2:<br>输入: nums = [1,5,10], n = 20<br>输出: 2<br>解释: 我们需要添加 [2, 4]。  </p><p>示例 3:<br>输入: nums = [1,2,2], n = 5<br>输出: 0  </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/patching-array">https://leetcode-cn.com/problems/patching-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><p>不可表示的最小数初始1，目标&gt;n，即&lt;=n都可被表示。遍历数组</p><p>当前数 &lt;不可表示的最小数，当前数可被表示<br>不可表示的最小数 = 1 + 可表示的最大数 = 1 + &lt;=当前数累加<br>= 1 + &lt;当前数累加 + 当前数 = 上轮不可表示的最小数 + 当前数<br>当前数 =不可表示的最小数，当前数不可表示，不可表示的最小数在数组，加当前数，同上<br>当前数 &gt;不可表示的最小数，当前数不可表示，不可表示的最小数不在数组<br>加不可表示的最小数，同上。直到当前数可被表示<br><a href="https://imgchr.com/i/rb7uWQ"><img src="https://s3.ax1x.com/2020/12/29/rb7uWQ.png" alt="rb7uWQ.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minPatches = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, n</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = r = <span class="hljs-number">0</span>, m = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (m &lt;= n) m += nums[i] &lt;= m ? nums[i++] : (r++, m)<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/patching-array/solution/jian-dan-si-lu-4xing-dai-ma-chao-100-by-1ex9y/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>力扣188 买卖股票的最佳时机IV</title>
    <link href="/2020/12/28/%E5%8A%9B%E6%89%A3188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/"/>
    <url>/2020/12/28/%E5%8A%9B%E6%89%A3188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p> </p><p>示例 1：<br>输入：k = 2, prices = [2,4,1]<br>输出：2<br>解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p><p>示例 2：<br>输入：k = 2, prices = [3,2,6,5,0,3]<br>输出：7<br>解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br>     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 </p><p>提示：</p><p>0 &lt;= k &lt;= 109<br>0 &lt;= prices.length &lt;= 1000<br>0 &lt;= prices[i] &lt;= 1000</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-递归"><a href="#一-递归" class="headerlink" title="一 递归"></a>一 递归</h4><h6 id="1-1-递归（超时）"><a href="#1-1-递归（超时）" class="headerlink" title="1.1 递归（超时）"></a>1.1 递归（超时）</h6><p>解题思路<br>递归模拟过程，天数i，交易次数j，有无股票s<br>无股票：max( 观望, 买入股票，现金 -= 当日股票价格 ）<br>有股票：max( 持有，卖出股票，现金 += 当日股票价格，交易次数 += 1 )<br>边界：交易次数 = k 或 数组越界</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, prices</span>) </span>&#123;<br>    d = <span class="hljs-function">(<span class="hljs-params">i, j, s</span>) =&gt;</span> j === k || i === prices.length ? <span class="hljs-number">0</span> : <br>                     s === <span class="hljs-literal">true</span> ? <span class="hljs-built_in">Math</span>.max(d(i + <span class="hljs-number">1</span>, j, s), d(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>) + prices[i]) :<br>                                  <span class="hljs-built_in">Math</span>.max(d(i + <span class="hljs-number">1</span>, j, s), d(i + <span class="hljs-number">1</span>, j, <span class="hljs-literal">true</span>) - prices[i])<br>    <span class="hljs-keyword">return</span> d(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>)<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/di-gui-dong-tai-gui-hua-1xing-dai-ma-2ji-th9r/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="1-2-递归-·-剪枝-·-缓存"><a href="#1-2-递归-·-剪枝-·-缓存" class="headerlink" title="1.2 递归 · 剪枝 · 缓存"></a>1.2 递归 · 剪枝 · 缓存</h5><p>解题思路<br>递归函数变化参数为i j s，以变化参数为键值，构建缓存函数<br>本题递归是三叉树（每次3分支），递归到底后向上回溯，遇键值相同不再递归<br>多变量组合生成唯一整数键名技巧：i j s从右向左，乘以 从1 到 前数的范围<br>s布尔值，转整型，[0, 1]，范围2，j 与 s组合，键名 = j * 2 + s * 1<br>j范围是数组长度，即1000，i 与 j 组合，键名 = i * 1000 + j<br>三变量组合,键名 = i * 1000 + j + s，生成键名 唯一且是整数，可用数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>:<br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, prices</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> h = [], t<br>    d = <span class="hljs-function">(<span class="hljs-params">i, j, s</span>) =&gt;</span> j === k || i === prices.length ? <span class="hljs-number">0</span> : <br>                     h[t = i * <span class="hljs-number">1000</span> + j * <span class="hljs-number">2</span> + s] ? h[t] : h[t] = <br>                     <span class="hljs-built_in">Math</span>.max(d(i + <span class="hljs-number">1</span>, j, s), <br>                     s ? d(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) + prices[i] : d(i + <span class="hljs-number">1</span>, j, <span class="hljs-number">1</span>) - prices[i])<br>    <span class="hljs-keyword">return</span> d(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>&#125;;<br><br><br><br><span class="hljs-built_in">Object</span>:<br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, prices</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> h = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), t<br>    d = <span class="hljs-function">(<span class="hljs-params">i, j, s</span>) =&gt;</span> j === k || i === prices.length ? <span class="hljs-number">0</span> : <br>                     h[t = i * <span class="hljs-number">1000</span> + j * <span class="hljs-number">2</span> + s] ? h[t] : h[t] = <br>                     <span class="hljs-built_in">Math</span>.max(d(i + <span class="hljs-number">1</span>, j, s), <br>                     s ? d(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) + prices[i] : d(i + <span class="hljs-number">1</span>, j, <span class="hljs-number">1</span>) - prices[i])<br>    <span class="hljs-keyword">return</span> d(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>&#125;;<br><br><br><br><br><span class="hljs-built_in">Map</span>:<br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, prices</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, t, t1<br>    d = <span class="hljs-function">(<span class="hljs-params">i, j, s</span>) =&gt;</span> j === k || i === prices.length ? <span class="hljs-number">0</span> : <br>                     h.has(t = i * <span class="hljs-number">1000</span> + j * <span class="hljs-number">2</span> + s) ? h.get(t) : (h.set(t, t1 =  <br>                     <span class="hljs-built_in">Math</span>.max(d(i + <span class="hljs-number">1</span>, j, s), <br>                     s ? d(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) + prices[i] : d(i + <span class="hljs-number">1</span>, j, <span class="hljs-number">1</span>) - prices[i])), t1)<br>    <span class="hljs-keyword">return</span> d(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>&#125;;<br><br><br><br><br><br><br><br><span class="hljs-built_in">Map</span> · <span class="hljs-number">1</span>行代码：卖出时，可用交易次数k - <span class="hljs-number">1</span>代替j + <span class="hljs-number">1</span>，边界相应变为k = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, prices, i = <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, t, t1</span>) </span>&#123; <span class="hljs-comment">// 换行可删</span><br>    <span class="hljs-keyword">return</span> k === <span class="hljs-number">0</span> || i === prices.length ? <span class="hljs-number">0</span> : <br>           h.has(t = i * <span class="hljs-number">1000</span> + k * <span class="hljs-number">2</span> + s) ? h.get(t) : (h.set(t, t1 =<br>           <span class="hljs-built_in">Math</span>.max(maxProfit(k, prices, i + <span class="hljs-number">1</span>, s, h), <br>           s ? maxProfit(k - <span class="hljs-number">1</span>, prices, i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, h) + prices[i] : maxProfit(k, prices, i + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, h) - prices[i])), t1)<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/di-gui-dong-tai-gui-hua-1xing-dai-ma-2ji-th9r/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-动态规划"><a href="#二-动态规划" class="headerlink" title="二 动态规划"></a>二 动态规划</h4><h5 id="2-1-动态规划"><a href="#2-1-动态规划" class="headerlink" title="2.1 动态规划"></a>2.1 动态规划</h5><p>解题思路<br>遍历，每天可能进行第[1, k]次中的某次交易 或 不交易<br>枚举一天的所有可能，取现金最大值<br>不交易，现金 不变<br>进行[1, k]的某次交易<br>买入，现金 -= 当天股票价格<br>卖出，现金 += 当天股票价格<br>每次交易都只有两个状态dp</p><p>交易前 有股票（交易前，没股票，交易不能发生）<br>交易后 无股票（交易后，股票被卖了）<br>dp[0]表示第1次交易前，有股票<br>dp[1]表示第1次交易后，无股票<br>dp[2]表示第2次交易前，有股票<br>dp[3]表示第2次交易后，无股票<br>…<br>dp[k]表示第k / 2 取整次交易，k次交易，就有k * 2交易状态<br>　　　 k为偶，交易前，有股票<br>　　　 k为奇，交易后，无股票  </p><p>dp索引与交易次数关系，推导状态转化方程<br><a href="https://imgchr.com/i/rbHS00"><img src="https://s3.ax1x.com/2020/12/29/rbHS00.png" alt="rbHS00.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, prices</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(k &lt;&lt; <span class="hljs-number">1</span>).fill(-prices[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; dp.length; j++) <br>            dp[j] = <span class="hljs-built_in">Math</span>.max(dp[j], (dp[j - <span class="hljs-number">1</span>] || <span class="hljs-number">0</span>) + (j &amp; <span class="hljs-number">1</span> ? prices[i] : -prices[i]))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, ...dp) <br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/di-gui-dong-tai-gui-hua-1xing-dai-ma-2ji-th9r/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="2-2-动态规划-·-优化"><a href="#2-2-动态规划-·-优化" class="headerlink" title="2.2 动态规划 · 优化"></a>2.2 动态规划 · 优化</h5><p>第0天，最多完成第1次交易1个状态，第1天，最多能完成第1次交易2个状态<br>第2天，最多完成第1次交易2个状态 + 第2次交易1个状态…<br>第i天，最多完成i + 1个交易状态，根据当天天数，动态缩小枚举范围</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, prices</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(k &lt;&lt; <span class="hljs-number">1</span>).fill(-prices[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-built_in">Math</span>.min(dp.length, i + <span class="hljs-number">1</span>); j--;) <span class="hljs-comment">// 顺序遍历也可</span><br>            dp[j] = <span class="hljs-built_in">Math</span>.max(dp[j], (dp[j - <span class="hljs-number">1</span>] || <span class="hljs-number">0</span>) + (j &amp; <span class="hljs-number">1</span> ? prices[i] : -prices[i]))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, ...dp) <br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/di-gui-dong-tai-gui-hua-1xing-dai-ma-2ji-th9r/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="2-3-动态规划-·-另一种DP方程"><a href="#2-3-动态规划-·-另一种DP方程" class="headerlink" title="2.3 动态规划 · 另一种DP方程"></a>2.3 动态规划 · 另一种DP方程</h5><p>Reudce 示例的dp方程有变化，颠倒有无股票前后顺序，思路一样，推导过程<br><a href="https://imgchr.com/i/rbH19e"><img src="https://s3.ax1x.com/2020/12/29/rbH19e.png" alt="rbH19e.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, prices</span>) </span>&#123; <span class="hljs-comment">// 换行可删</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, ...prices.reduce(<span class="hljs-function">(<span class="hljs-params">dp, price</span>) =&gt;</span> dp.map(<span class="hljs-function">(<span class="hljs-params">v, j, dp</span>) =&gt;</span> <br>        <span class="hljs-built_in">Math</span>.max(v, j &amp; <span class="hljs-number">1</span> ? (dp[j - <span class="hljs-number">3</span>] || <span class="hljs-number">0</span>) - price : dp[j + <span class="hljs-number">1</span>] + price)<br>    ), <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(k &lt;&lt; <span class="hljs-number">1</span>).fill(-prices[<span class="hljs-number">0</span>])))<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/di-gui-dong-tai-gui-hua-1xing-dai-ma-2ji-th9r/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣205 同构字符串</title>
    <link href="/2020/12/27/%E5%8A%9B%E6%89%A3205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/12/27/%E5%8A%9B%E6%89%A3205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><p>示例 1:<br>输入: s = “egg”, t = “add”<br>输出: true  </p><p>示例 2:<br>输入: s = “foo”, t = “bar”<br>输出: false</p><p>示例 3:<br>输入: s = “paper”, t = “title”<br>输出: true<br>说明:<br>你可以假设 s 和 t 具有相同的长度。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/isomorphic-strings">https://leetcode-cn.com/problems/isomorphic-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题跟290很像思路挺简单的直接贴宇哥题解了</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-索引"><a href="#一-索引" class="headerlink" title="一 索引"></a>一 索引</h4><p>解题思路<br>同构字符串，每字符 首次出现、最后出现、指定位出现 索引始终相同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">indexOf：<br><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++)<br>        <span class="hljs-keyword">if</span> (s.indexOf(s[i]) !== t.indexOf(t[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><br><br><br>lastIndexOf：<br><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = s.length; i--;)<br>        <span class="hljs-keyword">if</span> (s.lastIndexOf(s[i]) !== t.lastIndexOf(t[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/isomorphic-strings/solution/suo-yin-yuan-zu-dan-shuang-ha-xi-biao-5j-mxra/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-元组"><a href="#二-元组" class="headerlink" title="二 元组"></a>二 元组</h4><p>解题思路<br>同构字符串，分别去重与每位两两组合去重后长度相等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = s.length, S = <span class="hljs-built_in">Array</span>(i)<br>    <span class="hljs-keyword">while</span>(i--) <br>        S[i] = s[i] + <span class="hljs-string">&#x27;,&#x27;</span> + t[i]<br>    <span class="hljs-keyword">const</span> l = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(S).size<br>    <span class="hljs-keyword">return</span> l === <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(s).size &amp;&amp; l === <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(t).size<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/isomorphic-strings/solution/suo-yin-yuan-zu-dan-shuang-ha-xi-biao-5j-mxra/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="三-双哈希-·-索引"><a href="#三-双哈希-·-索引" class="headerlink" title="三 双哈希 · 索引"></a>三 双哈希 · 索引</h4><p>解题思路<br>哈希表存索引，同构字符串每字符上次出现索引始终相同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>：<br><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> S = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), T = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> a = s[i], b = t[i]<br>        <span class="hljs-keyword">if</span> (S[a] !== T[b]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        S[a] = i<br>        T[b] = i<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><br><br><br><br><span class="hljs-built_in">Map</span>：<br><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> S = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, T = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> a = s[i], b = t[i]<br>        <span class="hljs-keyword">if</span> (S.get(a) !== T.get(b)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        S.set(a, i)<br>        T.set(b, i)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><br><br><span class="hljs-built_in">Array</span>：<br><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> S = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">256</span>), T = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">256</span>), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> a = s.charCodeAt(i), b = t.charCodeAt(i)<br>        <span class="hljs-keyword">if</span> (S[a] !== T[b]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        S[a] = i + <span class="hljs-number">1</span><br>        T[b] = i + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/isomorphic-strings/solution/suo-yin-yuan-zu-dan-shuang-ha-xi-biao-5j-mxra/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="四-双哈希-·-双射"><a href="#四-双哈希-·-双射" class="headerlink" title="四 双哈希 · 双射"></a>四 双哈希 · 双射</h4><p>解题思路<br>同构字符串，每字符一一对应。我 → 你 + 你 → 我 = 双哈希。我中有你，你中有我</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>：<br><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> S = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), T = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> a = s[i], b = t[i]<br>        <span class="hljs-keyword">if</span> (S[a] &amp;&amp; S[a] !== b || T[b] &amp;&amp; T[b] !== a) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        S[a] = b<br>        T[b] = a<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><br><br><span class="hljs-attr">Map</span>:<br><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> S = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, T = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> a = s[i], b = t[i]<br>        <span class="hljs-keyword">if</span> (S.has(a) &amp;&amp; S.get(a) !== b || T.has(b) &amp;&amp; T.get(b) !== a) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        S.set(a, b)<br>        T.set(b, a)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><br><br><br><br><span class="hljs-built_in">Array</span>:<br><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> S = [], T = [], i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> a = s.charCodeAt(i), b = t.charCodeAt(i)<br>        <span class="hljs-keyword">if</span> (S[a] &amp;&amp; S[a] !== b || T[b] &amp;&amp; T[b] !== a) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        S[a] = b<br>        T[b] = a<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/isomorphic-strings/solution/suo-yin-yuan-zu-dan-shuang-ha-xi-biao-5j-mxra/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="五-单哈希"><a href="#五-单哈希" class="headerlink" title="五 单哈希"></a>五 单哈希</h4><p>解题思路<br>同构字符串，每字符一一对应。我 → 你 单哈希，判断 我中有你。哈希表值数组，判断 没有他/她</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>:<br><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> S = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> a = s[i], b = t[i]<br>        <span class="hljs-keyword">if</span> (S[a] ? S[a] !== b : <span class="hljs-built_in">Object</span>.values(S).includes(b)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <br>        S[a] = b<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><br><br><br><span class="hljs-built_in">Map</span>:<br><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> S = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> a = s[i], b = t[i]<br>        <span class="hljs-keyword">if</span> (S.has(a) ? S.get(a) !== b : <span class="hljs-built_in">Array</span>.from(S.values()).includes(b)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <br>        S.set(a, b)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><br><br><br><br><span class="hljs-built_in">Array</span>:<br><span class="hljs-keyword">var</span> isIsomorphic = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> S = [], i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i++ &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> a = s.charCodeAt(i), b = t.charCodeAt(i)<br>        <span class="hljs-keyword">if</span> (S[a] ? S[a] !== b : S.includes(b)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <br>        S[a] = b<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/isomorphic-strings/solution/suo-yin-yuan-zu-dan-shuang-ha-xi-biao-5j-mxra/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>索引</tag>
      
      <tag>元组</tag>
      
      <tag>哈希表</tag>
      
      <tag>双哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣85 最大矩形</title>
    <link href="/2020/12/26/%E5%8A%9B%E6%89%A385-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
    <url>/2020/12/26/%E5%8A%9B%E6%89%A385-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。<br> <a href="https://imgchr.com/i/rfYsAK"><img src="https://s3.ax1x.com/2020/12/26/rfYsAK.jpg" alt="rfYsAK.jpg"></a></p><p>示例 1：<br>输入：matrix = [[“1”,”0”,”1”,”0”,”0”],<br>[“1”,”0”,”1”,”1”,”1”],<br>[“1”,”1”,”1”,”1”,”1”],<br>[“1”,”0”,”0”,”1”,”0”]]<br>输出：6<br>解释：最大矩形如上图所示。</p><p>示例 2：<br>输入：matrix = []<br>输出：0  </p><p>示例 3：<br>输入：matrix = [[“0”]]<br>输出：0  </p><p>示例 4：<br>输入：matrix = [[“1”]]<br>输出：1  </p><p>示例 5：<br>输入：matrix = [[“0”,”0”]]<br>输出：0</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximal-rectangle">https://leetcode-cn.com/problems/maximal-rectangle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><p>解题思路<br>遍历矩阵，统计每行从左起连续1数量<br>遍历矩阵，当前点为右下角的矩形最大面积的最大值即解<br>向上求最大面积：宽 = 宽 连续1数 取小。高初始1，向上加1。直到连续1数为0<br>####<br><a href="https://imgchr.com/i/rIuPGd"><img src="https://s3.ax1x.com/2020/12/27/rIuPGd.png" alt="rIuPGd.png"></a><br><a href="https://imgchr.com/i/rI38y9"><img src="https://s3.ax1x.com/2020/12/27/rI38y9.png" alt="rI38y9.png"></a><br><a href="https://imgchr.com/i/rI33QJ"><img src="https://s3.ax1x.com/2020/12/27/rI33QJ.png" alt="rI33QJ.png"></a><br><a href="https://imgchr.com/i/rI3Ye1"><img src="https://s3.ax1x.com/2020/12/27/rI3Ye1.png" alt="rI3Ye1.png"></a><br><a href="https://imgchr.com/i/rI3GLR"><img src="https://s3.ax1x.com/2020/12/27/rI3GLR.png" alt="rI3GLR.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maximalRectangle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> i = matrix.length, ns = <span class="hljs-built_in">Array</span>.from(&#123;<span class="hljs-attr">length</span>: i&#125;, <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(matrix[<span class="hljs-number">0</span>].length)), r = <span class="hljs-number">0</span>, j, n<br>    <span class="hljs-keyword">while</span> (i--) <br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>; j &lt; matrix[<span class="hljs-number">0</span>].length; j++) <br>            ns[i][j] = matrix[i][j] === <span class="hljs-string">&#x27;1&#x27;</span> ? ++n : n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (j--) <br>        <span class="hljs-keyword">for</span> (i = matrix.length; i--;) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = i + <span class="hljs-number">1</span>, w = <span class="hljs-number">200</span>, h = <span class="hljs-number">0</span>, t; k-- &amp;&amp; ns[k][j];) &#123;<br>                <span class="hljs-keyword">if</span> (ns[k][j] &lt; w) w = ns[k][j]<br>                <span class="hljs-keyword">if</span> ((t = w * ++h) &gt; r) r = t<br>            &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/maximal-rectangle/solution/jian-dan-si-lu-11xing-dai-ma-chao-99-by-8hhlv/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>力扣455 分发饼干</title>
    <link href="/2020/12/25/%E5%8A%9B%E6%89%A3455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/"/>
    <url>/2020/12/25/%E5%8A%9B%E6%89%A3455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。  </p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p> <br>示例 1:<br>输入: g = [1,2,3], s = [1,1]<br>输出: 1<br>解释:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。</p><p>示例 2:<br>输入: g = [1,2], s = [1,2,3]<br>输出: 2<br>解释:<br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.  </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/assign-cookies">https://leetcode-cn.com/problems/assign-cookies</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>排列两个数组（一定要重新自定义方法！！！！因为他默认排序用第一位）然后进行遍历孩子，如果尺寸不满足胃口值就下一个，直到遍历完或饼干用完</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">g</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;<br>    g.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a - b;<br>&#125;);<br>    s.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a - b;<br>&#125;);<br>    <span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>,num=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;g.length;i++)&#123;<br>        <span class="hljs-keyword">while</span>(s[j]&lt;g[i])&#123;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j!=s.length)&#123;<br>            num++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j==s.length)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><p>贪心策略<br>孩子 选 饼干：如果 胃口小的孩子吃大饼干，剩下 胃口大的孩子没有饼干吃。所以如图<br>饼干 选 孩子：如果 大饼干给胃口小孩子吃，剩下 小饼干胃口大孩子不够吃。所以如图<br><a href="https://imgchr.com/i/rWTYu9"><img src="https://s3.ax1x.com/2020/12/25/rWTYu9.png" alt="rWTYu9.png"></a><br>迭代Math.min/Math.max每次从数组取最值，不如排序从头或尾移动指针效率高<br>所以，排序对于本题实现贪心算法，不是必须的，是为了更快地取最值</p><h4 id="一-单排序"><a href="#一-单排序" class="headerlink" title="一 单排序"></a>一 单排序</h4><p>只排序要取最值的数组。以倒序遍历为例，顺序也可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript">孩子 选 饼干：小 → 大<br><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>, i = g.length<br>    s.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a) <span class="hljs-comment">// 饼干降序</span><br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>        <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] &lt; g[i]) <span class="hljs-keyword">continue</span> <span class="hljs-comment">// 最大饼干 都满足不了 跳过</span><br>        j = s.length<br>        <span class="hljs-keyword">while</span> (j--)  &#123;<br>            <span class="hljs-keyword">if</span> (s[j] &gt;= g[i]) &#123; <span class="hljs-comment">// 找满足胃口的最小饼干</span><br>                r++<br>                s.splice(j, <span class="hljs-number">1</span>) <span class="hljs-comment">// 吃</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>饼干 选 孩子：小 → 大<br><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>, j = s.length<br>    g.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b) <span class="hljs-comment">// 孩子升序</span><br>    <span class="hljs-keyword">while</span> (j--) &#123;<br>        <span class="hljs-keyword">if</span> (g[<span class="hljs-number">0</span>] &gt; s[j]) <span class="hljs-keyword">continue</span> <span class="hljs-comment">// 胃口最小孩子 都满足不了 跳过</span><br>        i = g.length<br>        <span class="hljs-keyword">while</span> (i--)  &#123;<br>            <span class="hljs-keyword">if</span> (s[j] &gt;= g[i]) &#123; <span class="hljs-comment">// 找能满足的胃口最大的孩子</span><br>                r++<br>                g.splice(i, <span class="hljs-number">1</span>) <span class="hljs-comment">// 被吃</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/assign-cookies/solution/dan-shuang-pai-xu-you-xian-dui-lie-9jie-uhwdm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-双排序"><a href="#二-双排序" class="headerlink" title="二 双排序"></a>二 双排序</h4><p>解题思路<br>单排序时，未排序数组的元素都要遍历。双排序后<br><a href="https://imgchr.com/i/rWTWUP"><img src="https://s3.ax1x.com/2020/12/25/rWTWUP.png" alt="rWTWUP.png"></a><br>好处：移动指针，代替splice。不需要全部遍历<br>孩子选饼干：饼干指针到头，剩下 小饼干 + 胃口大的孩子，循环可提前终止<br>饼干选孩子：孩子指针到头，无孩子可分，循环可提前终止</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>, i = g.length, j = s.length<br>    g.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a) <span class="hljs-comment">// 孩子也降序</span><br>    s.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a)<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>        <span class="hljs-keyword">if</span> (j === -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span> <span class="hljs-comment">// 饼干指针到头</span><br>        <span class="hljs-keyword">while</span> (j--) <span class="hljs-comment">// 排除最小饼干</span><br>            <span class="hljs-keyword">if</span> (s[j] &gt;= g[i]) &#123;<br>                r++<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br><br><br><br>饼干 选 孩子：小 → 大<br><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>, i = g.length - <span class="hljs-number">1</span>, j = s.length<br>    g.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a)<br>    s.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a) <span class="hljs-comment">// 饼干也降序</span><br>    <span class="hljs-keyword">while</span> (j--) <br>        <span class="hljs-keyword">if</span> (s[j] &gt;= g[i]) &#123;<br>            r++<br>            <span class="hljs-keyword">if</span> (i-- === <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> <span class="hljs-comment">// 孩子指针到头</span><br>        &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br><br><br><br>空间优化<br>饼干 选 孩子代码更简洁。只有得到饼干，指针i才会移动。移动距离 = 得到饼干人数<br>饼干 选 孩子 · 优化 · 倒序：小 → 大<br><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = g.length - <span class="hljs-number">1</span>, j = s.length<br>    g.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a)<br>    s.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b - a)<br>    <span class="hljs-keyword">while</span> (j--) <br>        <span class="hljs-keyword">if</span> (s[j] &gt;= g[i]) <br>            <span class="hljs-keyword">if</span> (i-- === <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> g.length - i - <span class="hljs-number">1</span><br>&#125;;<br><br><br><br><br>饼干 选 孩子 · 优化 · 顺序：小 → 大<br><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = -<span class="hljs-number">1</span><br>    g.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b) <span class="hljs-comment">// 升序</span><br>    s.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b) <span class="hljs-comment">// 升序</span><br>    <span class="hljs-keyword">while</span> (++j &lt; s.length) <br>        <span class="hljs-keyword">if</span> (s[j] &gt;= g[i]) <br>            <span class="hljs-keyword">if</span> (++i === g.length) <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> i<br>&#125;;<br><br><br><br><br><br>孩子 选 饼干 · 优化 · 倒序：大 → 小<br><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = g.length, j = s.length - <span class="hljs-number">1</span><br>    g.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b) <span class="hljs-comment">// 升序</span><br>    s.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b) <span class="hljs-comment">// 升序</span><br>    <span class="hljs-keyword">while</span> (i--) <br>        <span class="hljs-keyword">if</span> (s[j] &gt;= g[i]) <br>            <span class="hljs-keyword">if</span> (j-- === <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> s.length - j - <span class="hljs-number">1</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/assign-cookies/solution/dan-shuang-pai-xu-you-xian-dui-lie-9jie-uhwdm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="三-优先队列"><a href="#三-优先队列" class="headerlink" title="三 优先队列"></a>三 优先队列</h4><p>解题思路<br>小根堆优先队列，代替sort，对放入元素自动升序排列。每次弹出都是最小值<br>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs javascript">饼干 选 孩子 · MinPriorityQueue：力扣专供JS的小根堆优先队列<br><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>, i = g.length, j = s.length,<br>        gS = <span class="hljs-keyword">new</span> MinPriorityQueue, sS = <span class="hljs-keyword">new</span> MinPriorityQueue<br>    <span class="hljs-keyword">while</span> (i--) gS.enqueue(<span class="hljs-keyword">void</span> <span class="hljs-number">0</span>, g[i])<br>    <span class="hljs-keyword">while</span> (j--) sS.enqueue(<span class="hljs-keyword">void</span> <span class="hljs-number">0</span>, s[j])<br>    <span class="hljs-keyword">while</span> (sS.isEmpty() === <span class="hljs-literal">false</span>) <br>        <span class="hljs-keyword">if</span> (sS.dequeue().priority &gt;= gS.front().priority) &#123;<br>            r++<br>            gS.dequeue()<br>            <span class="hljs-keyword">if</span> (gS.isEmpty()) <span class="hljs-keyword">break</span><br>        &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br><br><br><br>饼干 选 孩子 · 单调递增栈：数组模拟JS小根堆<br><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>, i = g.length, j = s.length,<br>        gS = <span class="hljs-keyword">new</span> MonotonicStack, sS = <span class="hljs-keyword">new</span> MonotonicStack<br>    <span class="hljs-keyword">while</span> (i--) gS.push(g[i])<br>    <span class="hljs-keyword">while</span> (j--) sS.push(s[j])<br>    <span class="hljs-keyword">while</span> (sS.length()) &#123;<br>        <span class="hljs-keyword">if</span> (sS.pop() &gt;= gS.top()) &#123;<br>            r++<br>            gS.pop()<br>            <span class="hljs-keyword">if</span> (gS.length() === <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonotonicStack</span> </span>&#123;<br>    <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">this</span>.stack = []<br>    &#125;<br>    length () &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack.length<br>    &#125;<br>    push (v) &#123;<br>        <span class="hljs-keyword">let</span> i = <span class="hljs-built_in">this</span>.length() - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">this</span>.stack[i] &lt; v) i--<br>        <span class="hljs-built_in">this</span>.stack.splice(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, v) <br>    &#125;<br>    top () &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.length() - <span class="hljs-number">1</span>]<br>    &#125;<br>    pop () &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack.pop()<br>    &#125;<br><br><br><br><br><br>饼干 选 孩子 · 二叉树：完全二叉树实现JS小根堆<br><span class="hljs-keyword">var</span> findContentChildren = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">g, s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>, i = g.length, j = s.length,<br>        gS = <span class="hljs-keyword">new</span> PriorityQueue, sS = <span class="hljs-keyword">new</span> PriorityQueue<br>    <span class="hljs-keyword">while</span> (i--) gS.add(g[i])<br>    <span class="hljs-keyword">while</span> (j--) sS.add(s[j])<br>    <span class="hljs-keyword">while</span> (sS.length()) <br>        <span class="hljs-keyword">if</span> (sS.shift().v &gt;= gS.first().v) &#123;<br>            r++<br>            gS.shift()<br>            <span class="hljs-keyword">if</span> (gS.length() === <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span><br>        &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">a</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.q = []<br>        a &amp;&amp; <span class="hljs-built_in">this</span>._build(a)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">v, second</span>)</span> &#123; <span class="hljs-comment">// 添加</span><br>        <span class="hljs-built_in">this</span>.q.push(&#123;v, second&#125;) <span class="hljs-comment">// 添加 值（比较用） 和 第二参数（索引）</span><br>        <span class="hljs-built_in">this</span>._up(<span class="hljs-built_in">this</span>.q.length - <span class="hljs-number">1</span>) <span class="hljs-comment">// 放入 二叉树的尾部，然后 上浮</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">shift</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 弹出</span><br>        <span class="hljs-keyword">var</span> n = <span class="hljs-built_in">this</span>.q.shift() <span class="hljs-comment">// 弹出 根节点</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.q.length) &#123; <span class="hljs-comment">// 如果还有节点</span><br>            <span class="hljs-built_in">this</span>.q.unshift(<span class="hljs-built_in">this</span>.q.pop()) <span class="hljs-comment">// 将 最尾部的节点 放到根节点位置</span><br>            <span class="hljs-built_in">this</span>._down(<span class="hljs-number">0</span>) <span class="hljs-comment">// 下沉 根节点</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">first</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 根节点的值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.q[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">empty</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 是否为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.q.length === <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">length</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-comment">// 返回队列长度</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.q.length<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">_build</span>(<span class="hljs-params">a</span>)</span> &#123; <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-built_in">this</span>.q.push(&#123;<span class="hljs-attr">v</span>:a[<span class="hljs-number">0</span>]&#125;) <span class="hljs-comment">// 先给空队列放入第0个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++) <span class="hljs-built_in">this</span>.q.unshift(&#123;<span class="hljs-attr">v</span>:a[i]&#125;), <span class="hljs-built_in">this</span>._down(<span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 从第1个元素起，把新元素放在根节点，然后下沉 根节点</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">_swap</span>(<span class="hljs-params">l, r, t</span>)</span> &#123; <span class="hljs-comment">// 交换</span><br>        t = <span class="hljs-built_in">this</span>.q[l], <span class="hljs-built_in">this</span>.q[l] = <span class="hljs-built_in">this</span>.q[r], <span class="hljs-built_in">this</span>.q[r] = t <span class="hljs-comment">// 交换两个节点</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">_down</span>(<span class="hljs-params">i</span>)</span>&#123; <span class="hljs-comment">// 下沉</span><br>        <span class="hljs-keyword">var</span> t = <span class="hljs-built_in">this</span>.q.length - <span class="hljs-number">2</span> &gt;&gt; <span class="hljs-number">1</span>, min, minI <span class="hljs-comment">// 叶子节点的根节点索引，下沉到 叶子节点的根节点停止</span><br>        <span class="hljs-keyword">while</span>(i &lt;= t)&#123;<br>            <span class="hljs-keyword">var</span> l = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, r = l + <span class="hljs-number">1</span> <span class="hljs-comment">// 左子节点的索引 = 当前节点索引 * 2 + 1，右子节点的索引 = 左子节点的索引 + 1</span><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">this</span>.q[l] ? <span class="hljs-built_in">this</span>.q[l].v : <span class="hljs-literal">Infinity</span>) &lt; (<span class="hljs-built_in">this</span>.q[r] ? <span class="hljs-built_in">this</span>.q[r].v : <span class="hljs-literal">Infinity</span>))<br>                 min = <span class="hljs-built_in">this</span>.q[l].v, minI = l<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/assign-cookies/solution/dan-shuang-pai-xu-you-xian-dui-lie-9jie-uhwdm/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序，优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣135 分发糖果</title>
    <link href="/2020/12/24/%E5%8A%9B%E6%89%A3135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
    <url>/2020/12/24/%E5%8A%9B%E6%89%A3135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。 </p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><p>每个孩子至少分配到 1 个糖果。<br>相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>示例 1:<br>输入: [1,0,2]<br>输出: 5<br>解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。  </p><p>示例 2:<br>输入: [1,2,2]<br>输出: 4<br>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。 </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/candy">https://leetcode-cn.com/problems/candy</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我记得自己acm刷过这道题结果居然忘记了说明记性确实不太好，然后看了宇哥的题解，1-3方法思路都是等于左右各遍历一次让左右都满足评分大则糖果数加1，其实我一开始想的还是区间的(#^.^#)</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">ratings</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> candy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ratings</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(ratings.length);<br>    r.fill(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;ratings.length;i++)&#123;<br>    <span class="hljs-keyword">if</span>(ratings[i]&gt;ratings[i-<span class="hljs-number">1</span>])<br>    r[i]=r[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=ratings.length-<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>    <span class="hljs-keyword">if</span>(ratings[i]&gt;ratings[i+<span class="hljs-number">1</span>])<br>    r[i]=<span class="hljs-built_in">Math</span>.max(r[i],r[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> r.reduce(<span class="hljs-function">(<span class="hljs-params">p,v</span>)=&gt;</span>p+v);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-动态规划-·-双指针"><a href="#一-动态规划-·-双指针" class="headerlink" title="一 动态规划 · 双指针"></a>一 动态规划 · 双指针</h4><p>解题思路<br>数组r每人糖果数，初始每人1个，双指针同时分别从首 尾扫描<br>指针i顺序找当前 &gt; 上个，当前 = 当前 和 上个 + 1 取大<br>指针j倒序找当前 &gt; 上个，当前 = 当前 和 上个 + 1 取大<br><a href="https://imgchr.com/i/rgvJzT"><img src="https://s3.ax1x.com/2020/12/24/rgvJzT.png" alt="rgvJzT.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> candy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ratings</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(ratings.length).fill(<span class="hljs-number">1</span>), j = ratings.length - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i &lt; ratings.length - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ratings[++i] &gt; ratings[i - <span class="hljs-number">1</span>]) r[i] = <span class="hljs-built_in">Math</span>.max(r[i], r[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> (ratings[--j] &gt; ratings[j + <span class="hljs-number">1</span>]) r[j] = <span class="hljs-built_in">Math</span>.max(r[j], r[j + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> r.reduce(<span class="hljs-function">(<span class="hljs-params">p, v</span>) =&gt;</span> p + v)<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/candy/solution/dong-tai-gui-hua-qu-jian-dan-shuang-zhi-ca1bl/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-线性扫描-·-数组"><a href="#二-线性扫描-·-数组" class="headerlink" title="二 线性扫描 · 数组"></a>二 线性扫描 · 数组</h4><p>解题思路<br>数组r每人糖果数，单指针i先顺序再倒序（先倒后顺也可）。以初始第0人1个为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> candy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ratings</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(ratings.length)<br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; ratings.length) <span class="hljs-comment">// 初始每人1个时，上解法保留if，删Math.max即可</span><br>        r[i] = ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>] ? r[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">1</span><br>    i--<br>    <span class="hljs-keyword">while</span> (i--) <span class="hljs-comment">// r[i] = Math.max(r[i], r[i + 1] + 1) 写成判断后，并入条件</span><br>        <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>] &amp;&amp; r[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> &gt; r[i]) r[i] = r[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> r.reduce(<span class="hljs-function">(<span class="hljs-params">p, v</span>) =&gt;</span> p + v)<br>&#125;;<br><br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/candy/solution/dong-tai-gui-hua-qu-jian-dan-shuang-zhi-ca1bl/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="三-线性扫描-·-变量"><a href="#三-线性扫描-·-变量" class="headerlink" title="三 线性扫描 · 变量"></a>三 线性扫描 · 变量</h4><p>解题思路<br>来自力扣官方<br>顺序left和倒序right都只关心自己，不用取大，专心赋值<br>取大在累加r合并left和right时进行，即上解法倒序循环与reduce合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> candy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ratings</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(ratings.length), right = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span><br>    left[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; ratings.length) &#123;<br>        left[i] = ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>] ? left[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>        r += left[i] &gt; right ? left[i] : right<br>        right = ratings[i - <span class="hljs-number">1</span>] &gt; ratings[i] ? right + <span class="hljs-number">1</span> : <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/candy/solution/dong-tai-gui-hua-qu-jian-dan-shuang-zhi-ca1bl/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="四-区间-·-整型"><a href="#四-区间-·-整型" class="headerlink" title="四 区间 · 整型"></a>四 区间 · 整型</h4><p>解题思路<br>扫描评分，比较前后分数<br>递增，发n + 1糖果（最小递增区间[1, 2]，当前2，n最小1）<br>递减 → 递增：重置n = 1<br>持平，发1糖果。重置n = 1 m = 0<br>递减，发m + 1糖果（最小递减区间[2, 1]，当前1，m最小0）<br>递增 → 递减：重置m = 0<br>递减区间，加m时机与实际分配顺序颠倒<br>实际分配时，新m始终与n相邻<br>m=n时 m++补1糖给拿n的人<br><a href="https://imgchr.com/i/rgxU9P"><img src="https://s3.ax1x.com/2020/12/24/rgxU9P.png" alt="rgxU9P.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> candy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ratings</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (ratings.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>, n = <span class="hljs-number">1</span>, m = <span class="hljs-number">0</span>, prev2<br>    <span class="hljs-keyword">while</span> (++i &lt; ratings.length) &#123;<br>        <span class="hljs-keyword">const</span> cur = ratings[i], prev = ratings[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> (cur &gt; prev) &#123;<br>            <span class="hljs-keyword">if</span> (prev &lt; prev2) n = <span class="hljs-number">1</span><br>            r += ++n<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur === prev) &#123;<br>            n = <span class="hljs-number">1</span><br>            m = <span class="hljs-number">0</span><br>            r ++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (prev &gt; prev2) m = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> (++m === n) m++<br>            r += m<br>        &#125;<br>        prev2 = prev <span class="hljs-comment">// 上上一人，与prev比较。递减 → 递增 重置 n 递增 → 递减 重置 m</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/candy/solution/dong-tai-gui-hua-qu-jian-dan-shuang-zhi-ca1bl/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="五-区间-·-布尔值"><a href="#五-区间-·-布尔值" class="headerlink" title="五 区间 · 布尔值"></a>五 区间 · 布尔值</h4><p>解题思路<br>布尔值f作标记：持平undefined，递增true，递减false。代替prev2与prev比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> candy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ratings</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (ratings.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>, n = <span class="hljs-number">1</span>, m = <span class="hljs-number">0</span>, f<br>    <span class="hljs-keyword">while</span> (++i &lt; ratings.length) &#123;<br>        <span class="hljs-keyword">const</span> cur = ratings[i], prev = ratings[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> (cur &gt; prev) &#123;<br>            <span class="hljs-keyword">if</span> (f === <span class="hljs-literal">false</span>) n = <span class="hljs-number">1</span><br>            f = <span class="hljs-literal">true</span><br>            r += ++n<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur === prev) &#123;<br>            f = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span><br>            n = <span class="hljs-number">1</span><br>            m = <span class="hljs-number">0</span><br>            r ++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (f) m = <span class="hljs-number">0</span><br>            f = <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">if</span> (++m === n) m++<br>            r += m<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/candy/solution/dong-tai-gui-hua-qu-jian-dan-shuang-zhi-ca1bl/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>SQL规范中，布尔值有三个状态，包括真，假和未知，后者在实现时，通常用null表示<br>部分编程语言，当变量未定义时，或不知道真假时，也会有默认状态，JS是undefined<br>利用布尔值的三态，我们可以多表示一种状态，但这会产生迷惑代码，例如</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> b<br><span class="hljs-keyword">if</span> (<span class="hljs-attr">b</span> === <span class="hljs-literal">true</span>) &#123;&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-attr">b</span> === <span class="hljs-literal">false</span>) &#123;&#125;<br><span class="hljs-keyword">else</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>推荐适合布尔值的场景：一定是二值逻辑，即非真即假<br>MySQL中，通过指定字段默认值或直接声明tinyint(1)，避免null存在<br>TS中，通过枚举enum定义状态，语义更明确，利于拓展<br>下面微调布尔值解法，用平衡三进制定义f，即true为1，false为-1,undefined为0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> candy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ratings</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (ratings.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, r = <span class="hljs-number">1</span>, n = <span class="hljs-number">1</span>, m = <span class="hljs-number">0</span>, f = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (++i &lt; ratings.length) &#123;<br>        <span class="hljs-keyword">const</span> cur = ratings[i], prev = ratings[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> (cur &gt; prev) &#123;<br>            <span class="hljs-keyword">if</span> (f === -<span class="hljs-number">1</span>) n = <span class="hljs-number">1</span><br>            f = <span class="hljs-number">1</span><br>            r += ++n<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur === prev) &#123;<br>            f = <span class="hljs-number">0</span><br>            n = <span class="hljs-number">1</span><br>            m = <span class="hljs-number">0</span><br>            r ++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (f === <span class="hljs-number">1</span>) m = <span class="hljs-number">0</span><br>            f = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> (++m === n) m++<br>            r += m<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/candy/solution/dong-tai-gui-hua-qu-jian-dan-shuang-zhi-ca1bl/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>区间</tag>
      
      <tag>指针</tag>
      
      <tag>双指针</tag>
      
      <tag>标记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣387 字符串中的第一个唯一字符</title>
    <link href="/2020/12/23/%E5%8A%9B%E6%89%A3387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/"/>
    <url>/2020/12/23/%E5%8A%9B%E6%89%A3387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p> </p><p>示例：<br>s = “leetcode”<br>返回 0</p><p>s = “loveleetcode”<br>返回 2</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string">https://leetcode-cn.com/problems/first-unique-character-in-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一开始用字符串删改后indexOf判断后面还有没有后面发现还要直接把此类元素全都删除了比较麻烦，就用了对象，同时写了一个通过value找key的函数即可</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> a=&#123;&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;s.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[s[i]])&#123;<br>            a[s[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            a[s[i]]=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.indexOf(findKey(a,<span class="hljs-number">1</span>));<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findKey</span>(<span class="hljs-params">obj, value, compare = (a, b) =&gt; a === b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(obj).find(<span class="hljs-function"><span class="hljs-params">k</span> =&gt;</span> compare(obj[k], value))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-哈希表"><a href="#一-哈希表" class="headerlink" title="一 哈希表"></a>一 哈希表</h4><p>解题思路<br>遍历字符串，哈希表统计字符出现次数。再遍历字符串，找出现次数为1的字符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>：Uint16值[<span class="hljs-number">0</span>, <span class="hljs-number">65535</span>]过测试用例足够，实际应大一些，下同<br><br><br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(<span class="hljs-number">26</span>), i = s.length<br>    <span class="hljs-keyword">while</span> (i--) h[s.charCodeAt(i) - <span class="hljs-number">97</span>]++<br>    i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; s.length) <br>        <span class="hljs-keyword">if</span> (h[s.charCodeAt(i) - <span class="hljs-number">97</span>] === <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> i<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br><br><br><br><br><span class="hljs-built_in">Object</span><br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> h = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), i = s.length<br>    <span class="hljs-keyword">while</span> (i--) h[s[i]] ? h[s[i]]++ : h[s[i]] = <span class="hljs-number">1</span><br>    i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; s.length) <br>        <span class="hljs-keyword">if</span> (h[s[i]] === <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> i<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br><br><br><br><br><br><span class="hljs-built_in">Map</span><br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, i = s.length<br>    <span class="hljs-keyword">while</span> (i--) h.set(s[i], h.has(s[i]) ? h.get(s[i]) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>)<br>    i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; s.length) <br>        <span class="hljs-keyword">if</span> (h.get(s[i]) === <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> i<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/first-unique-character-in-a-string/solution/wei-zheng-ze-ha-xi-ji-he-dui-lie-yuan-sh-bupy/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-哈希映射"><a href="#二-哈希映射" class="headerlink" title="二 哈希映射"></a>二 哈希映射</h4><p>解题思路<br>遍历字符串，字符首次出现值设索引。再出现值设-1。遍历哈希表，找值!=-1字符  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Map</span>：找到clear提前终止forEach<br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; s.length) h.set(s[i], h.has(s[i]) ? -<span class="hljs-number">1</span> : i)<br>    i = -<span class="hljs-number">1</span><br>    h.forEach(<span class="hljs-function">(<span class="hljs-params">v, _, h</span>) =&gt;</span> v !== -<span class="hljs-number">1</span> &amp;&amp; (i = v, h.clear()))<br>    <span class="hljs-keyword">return</span> i<br>&#125;;<br><br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/first-unique-character-in-a-string/solution/wei-zheng-ze-ha-xi-ji-he-dui-lie-yuan-sh-bupy/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="三-原生"><a href="#三-原生" class="headerlink" title="三 原生"></a>三 原生</h4><p>解题思路<br>唯一字符 首次出现索引 = 该字符最后出现索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) <br>        <span class="hljs-keyword">if</span> (s.indexOf(s[i]) === s.lastIndexOf(s[i]))<br>            <span class="hljs-keyword">return</span> i<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/first-unique-character-in-a-string/solution/wei-zheng-ze-ha-xi-ji-he-dui-lie-yuan-sh-bupy/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="四-原生-·-集合"><a href="#四-原生-·-集合" class="headerlink" title="四 原生 · 集合"></a>四 原生 · 集合</h4><p>解题思路<br>重复字符 首次出现索引 != 该字符最后出现索引<br>重复字符 首次出现索引以后，仍可以找到该字符<br>以上都只关心首次出现索引，用集合Set记录出现过字符。字符再出现，跳过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript">astIndexOf：思路<span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length)<br>        <span class="hljs-keyword">if</span> (r.has(s[i]) === <span class="hljs-literal">false</span>)<br>            <span class="hljs-keyword">if</span> (i === s.lastIndexOf(s[i])) <span class="hljs-keyword">return</span> i<br>            <span class="hljs-keyword">else</span> r.add(s[i])<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br><br>indexOf：思路<span class="hljs-number">2</span>，第二参数，代表从该位置及该位置以后查找<br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length)<br>        <span class="hljs-keyword">if</span> (r.has(s[i]) === <span class="hljs-literal">false</span>)<br>            <span class="hljs-keyword">if</span> (s.indexOf(s[i], i + <span class="hljs-number">1</span>) === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i<br>            <span class="hljs-keyword">else</span> r.add(s[i])<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br><br>includes：思路<span class="hljs-number">2</span>，第二参数，代表从该位置及该位置以后查找<br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length)<br>        <span class="hljs-keyword">if</span> (r.has(s[i]) === <span class="hljs-literal">false</span>)<br>            <span class="hljs-keyword">if</span> (s.includes(s[i], i + <span class="hljs-number">1</span>) === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> i<br>            <span class="hljs-keyword">else</span> r.add(s[i])<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/first-unique-character-in-a-string/solution/wei-zheng-ze-ha-xi-ji-he-dui-lie-yuan-sh-bupy/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="五-原生-·-位"><a href="#五-原生-·-位" class="headerlink" title="五 原生 · 位"></a>五 原生 · 位</h4><p>解题思路<br>小写字母unicode编码 - 97对应[0, 25]，再对应二进制中的位。1字母存在，0不存在<br>bit = 1即a存在bit = 101即c和a存在。从右到左，第0到25位，对应a到z<br><a href="https://imgchr.com/i/r6Tczn"><img src="https://s3.ax1x.com/2020/12/23/r6Tczn.png" alt="r6Tczn.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript">lastIndexOf<br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">new</span> Bit, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">let</span> j = s.charCodeAt(i) - <span class="hljs-number">97</span><br>        <span class="hljs-keyword">if</span> (r.has(j) === <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> (i === s.lastIndexOf(s[i])) <span class="hljs-keyword">return</span> i<br>            <span class="hljs-keyword">else</span> r.add(j)<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br><br>indexOf<br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">new</span> Bit, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">let</span> j = s.charCodeAt(i) - <span class="hljs-number">97</span><br>        <span class="hljs-keyword">if</span> (r.has(j) === <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> (s.indexOf(s[i], i + <span class="hljs-number">1</span>) === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i<br>            <span class="hljs-keyword">else</span> r.add(j)<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br><br><br>includes<br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">new</span> Bit, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">let</span> j = s.charCodeAt(i) - <span class="hljs-number">97</span><br>        <span class="hljs-keyword">if</span> (r.has(j) === <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">if</span> (s.includes(s[i], i + <span class="hljs-number">1</span>) === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> i<br>            <span class="hljs-keyword">else</span> r.add(j)<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/first-unique-character-in-a-string/solution/wei-zheng-ze-ha-xi-ji-he-dui-lie-yuan-sh-bupy/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="六-正则"><a href="#六-正则" class="headerlink" title="六 正则"></a>六 正则</h4><p>解题思路<br>search返回与indexOf一致。不能传参指定起始查找位置，但支持正则<br>match返回null或对象。不能传参指定起始查找位置，但支持正则<br>用正则的大括号语法，/\w{1,}a/中{1,}指定(1, end]查找a。改写上面原生解法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript">search（超时）<br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length)<br>        <span class="hljs-keyword">if</span> (r.has(s[i]) === <span class="hljs-literal">false</span>) <br>            <span class="hljs-keyword">if</span> (s.search(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`\\w&#123;<span class="hljs-subst">$&#123;i + <span class="hljs-number">1</span>&#125;</span>,&#125;<span class="hljs-subst">$&#123;s[i]&#125;</span>`</span>)) === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i<br>            <span class="hljs-keyword">else</span> r.add(s[i])<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br><br><br><br>match（超时）<br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length)<br>        <span class="hljs-keyword">if</span> (r.has(s[i]) === <span class="hljs-literal">false</span>) <br>            <span class="hljs-keyword">if</span> (s.match(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`\\w&#123;<span class="hljs-subst">$&#123;i + <span class="hljs-number">1</span>&#125;</span>,&#125;<span class="hljs-subst">$&#123;s[i]&#125;</span>`</span>)) === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> i<br>            <span class="hljs-keyword">else</span> r.add(s[i])<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br><br><br><br>replace：遇到重复字符，只保留一个，后面都用占位符代替。这样不需要集合存重复字符<br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">if</span>(s[i] !== <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">if</span> (s.indexOf(s[i], i + <span class="hljs-number">1</span>) === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i<br>            <span class="hljs-keyword">else</span> s = s.replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(s[i], <span class="hljs-string">&#x27;g&#x27;</span>), <span class="hljs-function">(<span class="hljs-params">v, j</span>) =&gt;</span> j &gt; i ? <span class="hljs-string">&#x27;0&#x27;</span> : v) <span class="hljs-comment">// 仅保留当前位</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>&#125;;<br><br><br><br>sort：排序后，重复字符相连，/(\w)\<span class="hljs-number">1</span>+/匹配连续重复字符，全部删除，只剩下唯一字符<br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> _s = s.split(<span class="hljs-string">&#x27;&#x27;</span>).sort().join(<span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-regexp">/(\w)\1+/g</span>, <span class="hljs-string">&#x27;&#x27;</span>), i = -<span class="hljs-number">1</span>, min = <span class="hljs-literal">Infinity</span><br>    <span class="hljs-keyword">while</span>(++i &lt; _s.length) min = <span class="hljs-built_in">Math</span>.min(min, s.indexOf(_s[i])) <span class="hljs-comment">// 找唯一字符中最前的</span><br>    <span class="hljs-keyword">return</span> _s.length ? min : -<span class="hljs-number">1</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/first-unique-character-in-a-string/solution/wei-zheng-ze-ha-xi-ji-he-dui-lie-yuan-sh-bupy/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="七-原生-·-贪心"><a href="#七-原生-·-贪心" class="headerlink" title="七 原生 · 贪心"></a>七 原生 · 贪心</h4><p>解题思路<br>遍历26个字母，找出所有唯一字符：即 首次出现索引 = 最后出现索引 的字符<br>贪心策略：找唯一字符最前的，即 索引最小的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">96</span>, min = <span class="hljs-literal">Infinity</span><br>    <span class="hljs-keyword">while</span> (++i &lt; <span class="hljs-number">97</span> + <span class="hljs-number">26</span>) &#123;<span class="hljs-comment">// 常量运算自动编译结果，运行时已是++i &lt; 123，即 常量折叠</span><br>        <span class="hljs-keyword">let</span> a = <span class="hljs-built_in">String</span>.fromCharCode(i), j = s.indexOf(a)<br>        <span class="hljs-keyword">if</span> (j &gt; -<span class="hljs-number">1</span> &amp;&amp; j === s.lastIndexOf(a) &amp;&amp; j &lt; min) min = j<br>    &#125;<br>    <span class="hljs-keyword">return</span> min === <span class="hljs-literal">Infinity</span> ? -<span class="hljs-number">1</span> : min<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/first-unique-character-in-a-string/solution/wei-zheng-ze-ha-xi-ji-he-dui-lie-yuan-sh-bupy/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="八-懒队列"><a href="#八-懒队列" class="headerlink" title="八 懒队列"></a>八 懒队列</h4><p>解题思路<br>来自力扣官方思路。这里用数组实现一个懒队列<br>可以通过回调函数指定条件，不断弹出符合条件的第0项。直到第0项不符合条件<br>遍历字符<br>未出现：放入懒队列<br>出现过：清理懒队列<br>结果只关心第0项。所以懒清理，只要清理到第0项不是重复的就收工<br>是不是重复，判断结果通过回调函数传入懒队列的clear，重复返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span><br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = <span class="hljs-keyword">new</span> LazyQueen, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(<span class="hljs-number">26</span>), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length) <br>        h[s.charCodeAt(i) - <span class="hljs-number">97</span>]++ ? q.clear(<span class="hljs-function"><span class="hljs-params">first</span> =&gt;</span> h[first] &gt; <span class="hljs-number">1</span>)<br>                                  : q.add(s.charCodeAt(i) - <span class="hljs-number">97</span>, i)<br>    <span class="hljs-keyword">return</span> q.length() ? q.second() : -<span class="hljs-number">1</span><br>&#125;;<br><br><br><br><br><span class="hljs-built_in">Set</span>：用另一个<span class="hljs-built_in">Set</span>记录已出现过的字符<br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = <span class="hljs-keyword">new</span> LazyQueen, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>, r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length) <br>        <span class="hljs-keyword">if</span> (h.has(s[i])) &#123;<br>            r.add(s[i])<br>            q.clear(<span class="hljs-function"><span class="hljs-params">first</span> =&gt;</span> r.has(first))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            h.add(s[i])<br>            q.add(s[i], i)<br>        &#125;<br>    <span class="hljs-keyword">return</span> q.length() ? q.second() : -<span class="hljs-number">1</span><br>&#125;;<br><br><br><br><br>位：用上面实现过的Bit类<br><span class="hljs-keyword">var</span> firstUniqChar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = <span class="hljs-keyword">new</span> LazyQueen, h = <span class="hljs-keyword">new</span> Bit, r = <span class="hljs-keyword">new</span> Bit, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">let</span> j = s.charCodeAt(i) - <span class="hljs-number">97</span><br>        <span class="hljs-keyword">if</span> (h.has(j)) &#123;<br>            r.add(j)<br>            q.clear(<span class="hljs-function"><span class="hljs-params">first</span> =&gt;</span> r.has(first))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            h.add(j)<br>            q.add(j, i)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> q.length() ? q.second() : -<span class="hljs-number">1</span><br>&#125;;<br><br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/first-unique-character-in-a-string/solution/wei-zheng-ze-ha-xi-ji-he-dui-lie-yuan-sh-bupy/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
      <tag>哈希</tag>
      
      <tag>集合</tag>
      
      <tag>位运算</tag>
      
      <tag>正则</tag>
      
      <tag>原生</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣103 二叉树的锯齿形层序遍历</title>
    <link href="/2020/12/22/%E5%8A%9B%E6%89%A3103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/12/22/%E5%8A%9B%E6%89%A3103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],  </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回锯齿形层序遍历如下：  </p><p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-广度优先搜索"><a href="#一-广度优先搜索" class="headerlink" title="一 广度优先搜索"></a>一 广度优先搜索</h4><p>解题思路<br>广度优先遍历二叉树，结果集长度的奇偶性判断放置顺序<br>缓存长度：l = 队列长度。提示所有代码f函数删除后即通用模版，适用遍历取值和层级<br>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript">缓存长度：l = 队列长度：<br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = root ? [root] : [], r = []<br>    <span class="hljs-keyword">while</span> (q.length) &#123;<br>        <span class="hljs-keyword">let</span> l = q.length<br>        r.push([])<br>        <span class="hljs-keyword">while</span>(l--) &#123;<br>            <span class="hljs-keyword">let</span> n = q.shift()<br>            f(r, n.val)<br>            n.left &amp;&amp; q.push(n.left)<br>            n.right &amp;&amp; q.push(n.right)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>f = <span class="hljs-function">(<span class="hljs-params">r, v</span>) =&gt;</span> r.length &amp; <span class="hljs-number">1</span> ? r[r.length - <span class="hljs-number">1</span>].push(v) : r[r.length - <span class="hljs-number">1</span>].unshift(v)<br><br>指针：i++代替shift，j++代替push，l--代替unshift<br><br><br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = root ? [root] : [], r = [], i = <span class="hljs-number">0</span>, l<br>    <span class="hljs-keyword">while</span> (l = q.length - i) &#123;<br>        <span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span><br>        r.push(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Int8Array</span>(l))<br>        <span class="hljs-keyword">while</span>(l--) &#123;<br>            <span class="hljs-keyword">let</span> n = q[i++]<br>            r.length &amp; <span class="hljs-number">1</span> ? r[r.length - <span class="hljs-number">1</span>][j++] = n.val <br>                         : r[r.length - <span class="hljs-number">1</span>][l] = n.val<br>            n.left &amp;&amp; q.push(n.left)<br>            n.right &amp;&amp; q.push(n.right)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br><br>分层标记：<span class="hljs-literal">undefined</span>作分层标记<br><br><br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = root ? [root, <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>] : [], r = []<br>    <span class="hljs-keyword">while</span> (q.length &gt; <span class="hljs-number">1</span>) &#123;<br>        r.push([])<br>        <span class="hljs-keyword">while</span>(n = q.shift()) &#123;<br>            f(r, n.val)<br>            n.left &amp;&amp; q.push(n.left)<br>            n.right &amp;&amp; q.push(n.right)<br>        &#125;<br>        q.push(<span class="hljs-keyword">void</span> <span class="hljs-number">0</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>f = <span class="hljs-function">(<span class="hljs-params">r, v</span>) =&gt;</span> r.length &amp; <span class="hljs-number">1</span> ? r[r.length - <span class="hljs-number">1</span>].push(v) : r[r.length - <span class="hljs-number">1</span>].unshift(v)<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/solution/shen-du-yan-du-di-gui-die-dai-qian-zhong-nucl/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="1-2-递归-·-伪"><a href="#1-2-递归-·-伪" class="headerlink" title="1.2 递归 · 伪"></a>1.2 递归 · 伪</h5><p>解题思路<br>递归用堆栈，不借助队列实现不限制类型的二叉树的广度优先搜索几近不可能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">深度优先前序遍历放入数组 + 广度优先取出。无意义，测试排除本解法<br><br><br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> r = [], q = []<br>    d = <span class="hljs-function">(<span class="hljs-params">n, l</span>) =&gt;</span> n &amp;&amp; (q[l] ? q[l].push(n)<br>                             : q[l] = [n],<br>                        d(n.left, l + <span class="hljs-number">1</span>),<br>                        d(n.right, l + <span class="hljs-number">1</span>))<br>    d(root, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> q.map(<span class="hljs-function">(<span class="hljs-params">ns, i</span>) =&gt;</span> (i &amp; <span class="hljs-number">1</span> ? ns.reverse() : ns).map(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n.val))<br>&#125;;<br>结果<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/solution/shen-du-yan-du-di-gui-die-dai-qian-zhong-nucl/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-深度优先搜索"><a href="#二-深度优先搜索" class="headerlink" title="二 深度优先搜索"></a>二 深度优先搜索</h4><h5 id="2-1-递归"><a href="#2-1-递归" class="headerlink" title="2.1 递归"></a>2.1 递归</h5><p>解题思路<br>每次递归层次+1。根据层次的奇偶性判断放置顺序  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript">前序遍历<br><br><br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = root ? [[root, <span class="hljs-number">0</span>]] : [], r = []<br>    <span class="hljs-keyword">while</span> (q.length) &#123;<br>        <span class="hljs-keyword">let</span> [n, l] = q.shift()<br>        f(r, l, n.val)<br>        n.left &amp;&amp; q.push([n.left, l + <span class="hljs-number">1</span>])<br>        n.right &amp;&amp; q.push([n.right, l + <span class="hljs-number">1</span>])<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>f = <span class="hljs-function">(<span class="hljs-params">r, l, v</span>) =&gt;</span> (r[l] || (r[l] = []), l &amp; <span class="hljs-number">1</span> ? r[l].unshift(v) : r[l].push(v))<br><br><br>前序遍历 · 浅拷贝：这样写成<span class="hljs-number">1</span>行更短<br><br><br>vvar zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = []<br>    d = <span class="hljs-function">(<span class="hljs-params">n, l</span>) =&gt;</span> n &amp;&amp; (r[l] = l &amp; <span class="hljs-number">1</span> ? [n.val].concat(r[l] || []) <br>                                     : (r[l] || []).concat(n.val),<br>                        d(n.left, l + <span class="hljs-number">1</span>),<br>                        d(n.right, l + <span class="hljs-number">1</span>))<br>    d(root, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><span class="hljs-comment">// 1行代码</span><br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, r = []</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (d = <span class="hljs-function">(<span class="hljs-params">n, l</span>) =&gt;</span> n &amp;&amp; (r[l] = l &amp; <span class="hljs-number">1</span> ? [n.val].concat(r[l] || []) : (r[l] || []).concat(n.val), d(n.left, l + <span class="hljs-number">1</span>), d(n.right, l + <span class="hljs-number">1</span>)))(root, <span class="hljs-number">0</span>), r<br>&#125;;<br><br>中序遍历：<br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = []<br>    d = <span class="hljs-function">(<span class="hljs-params">n, l</span>) =&gt;</span> n &amp;&amp; (d(n.left, l + <span class="hljs-number">1</span>),<br>                        f(r, l, n.val),<br>                        d(n.right, l + <span class="hljs-number">1</span>))<br>    d(root, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>f = <span class="hljs-function">(<span class="hljs-params">r, l, v</span>) =&gt;</span> (r[l] || (r[l] = []), l &amp; <span class="hljs-number">1</span> ? r[l].unshift(v) : r[l].push(v))<br><br><br><br>后序遍历：<br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = []<br>    d = <span class="hljs-function">(<span class="hljs-params">n, l</span>) =&gt;</span> n &amp;&amp; (d(n.left, l + <span class="hljs-number">1</span>),<br>                        d(n.right, l + <span class="hljs-number">1</span>),<br>                        f(r, l, n.val))<br>    d(root, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>f = <span class="hljs-function">(<span class="hljs-params">r, l, v</span>) =&gt;</span> (r[l] || (r[l] = []), l &amp; <span class="hljs-number">1</span> ? r[l].unshift(v) : r[l].push(v))<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/solution/shen-du-yan-du-di-gui-die-dai-qian-zhong-nucl/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="2-2-迭代-·-栈"><a href="#2-2-迭代-·-栈" class="headerlink" title="2.2 迭代 · 栈"></a>2.2 迭代 · 栈</h5><p>解题思路<br>队列中记录节点及节点所在层次。根据层次的奇偶性判断放置顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javascript">前序遍历：<br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = root ? [[root, <span class="hljs-number">0</span>]] : [], r = []<br>    <span class="hljs-keyword">while</span> (q.length) &#123;<br>        <span class="hljs-keyword">let</span> [n, l] = q.shift()<br>        f(r, l, n.val)<br>        n.left &amp;&amp; q.push([n.left, l + <span class="hljs-number">1</span>])<br>        n.right &amp;&amp; q.push([n.right, l + <span class="hljs-number">1</span>])<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>f = <span class="hljs-function">(<span class="hljs-params">r, l, v</span>) =&gt;</span> (r[l] || (r[l] = []), l &amp; <span class="hljs-number">1</span> ? r[l].unshift(v) : r[l].push(v))<br><br>中序遍历：<br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = [], r = [], l = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (root || q.length) &#123;<br>        <span class="hljs-keyword">while</span>(root) &#123;<br>            q.push([root, l++])<br>            root = root.left<br>        &#125;<br>        [root, l] = q.pop()<br>        f(r, l, root.val)<br>        root = root.right<br>        l++<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>f = <span class="hljs-function">(<span class="hljs-params">r, l, v</span>) =&gt;</span> (r[l] || (r[l] = []), l &amp; <span class="hljs-number">1</span> ? r[l].unshift(v) : r[l].push(v))<br><br><br>后序遍历；<br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> q = [], r = [], l = <span class="hljs-number">0</span>, visited = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">while</span> (root || q.length) &#123;<br>        <span class="hljs-keyword">while</span>(root) &#123;<br>            q.push([root, l++])<br>            root = root.left<br>        &#125;<br>        [root, l] = q.pop()<br>        <span class="hljs-keyword">if</span>(root.right === <span class="hljs-literal">null</span> || root.right === visited) &#123;<br>            f(r, l, root.val)<br>            visited = root<br>            root = <span class="hljs-literal">null</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            q.push([root, l++])<br>            root = root.right<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>f = <span class="hljs-function">(<span class="hljs-params">r, l, v</span>) =&gt;</span> (r[l] || (r[l] = []), l &amp; <span class="hljs-number">1</span> ? r[l].unshift(v) : r[l].push(v))<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/solution/shen-du-yan-du-di-gui-die-dai-qian-zhong-nucl/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h5 id="2-3-迭代-·-Morris"><a href="#2-3-迭代-·-Morris" class="headerlink" title="2.3 迭代 · Morris"></a>2.3 迭代 · Morris</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Morris · 前序遍历:<br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> []<br>    <span class="hljs-keyword">const</span> r = []<br>    root.l = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (root) &#123;<br>        <span class="hljs-keyword">let</span> t = root.l<br>        <span class="hljs-keyword">if</span> (root.left) &#123;<br>            <span class="hljs-keyword">var</span> p = root.left<br>            <span class="hljs-keyword">while</span> (p.right &amp;&amp; p.right !== root) p = p.right<br>            <span class="hljs-keyword">if</span> (p.right === <span class="hljs-literal">null</span>) &#123;<br>                f(r, root.l, root.val)<br>                p.right = root<br>                root = root.left<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                root = root.right<br>                p.right = <span class="hljs-literal">null</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            f(r, root.l, root.val)<br>            root = root.right<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root &amp;&amp; root.l === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) root.l = t + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>f = <span class="hljs-function">(<span class="hljs-params">r, l, v</span>) =&gt;</span> (r[l] || (r[l] = []), l &amp; <span class="hljs-number">1</span> ? r[l].unshift(v) : r[l].push(v))<br><br><br><br><br>Morris · 中序遍历:<br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> []<br>    <span class="hljs-keyword">const</span> r = []<br>    root.l = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (root) &#123;<br>        <span class="hljs-keyword">let</span> t = root.l<br>        <span class="hljs-keyword">if</span> (root.left) &#123;<br>            <span class="hljs-keyword">var</span> p = root.left<br>            <span class="hljs-keyword">while</span> (p.right &amp;&amp; p.right !== root) p = p.right<br>            <span class="hljs-keyword">if</span> (p.right === <span class="hljs-literal">null</span>) &#123;<br>                p.right = root<br>                root = root.left<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                f(r, root.l, root.val)<br>                root = root.right<br>                p.right = <span class="hljs-literal">null</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            f(r, root.l, root.val)<br>            root = root.right<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root &amp;&amp; root.l === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) root.l = t + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>f = <span class="hljs-function">(<span class="hljs-params">r, l, v</span>) =&gt;</span> (r[l] || (r[l] = []), l &amp; <span class="hljs-number">1</span> ? r[l].unshift(v) : r[l].push(v))<br><br>Morris · 后序遍历<br><br><br><span class="hljs-keyword">var</span> zigzagLevelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> []<br>    <span class="hljs-keyword">let</span> r = [], n = root<br>    root.l = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (root) &#123;<br>        <span class="hljs-keyword">let</span> t = root.l<br>        <span class="hljs-keyword">if</span> (root.left) &#123;<br>            <span class="hljs-keyword">var</span> p = root.left<br>            <span class="hljs-keyword">while</span> (p.right &amp;&amp; p.right !== root) p = p.right<br>            <span class="hljs-keyword">if</span> (p.right === <span class="hljs-literal">null</span>) &#123;<br>                p.right = root<br>                root = root.left<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                p.right = <span class="hljs-literal">null</span><br>                f1(root.left, r)<br>                root = root.right<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root = root.right<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root &amp;&amp; root.l === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) root.l = t + <span class="hljs-number">1</span><br>    &#125;<br>    f1(n, r)<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>f = <span class="hljs-function">(<span class="hljs-params">r, l, v</span>) =&gt;</span> (r[l] || (r[l] = []), l &amp; <span class="hljs-number">1</span> ? r[l].unshift(v) : r[l].push(v))<br>f1 = <span class="hljs-function">(<span class="hljs-params">n, r</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> t = f2(n), root = t<br>    <span class="hljs-keyword">while</span>(root) &#123;<br>        f(r, root.l, root.val)<br>        root = root.right<br>    &#125;<br>    f2(t)<br>&#125;<br>f2 = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> pre = next = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">while</span>(n) &#123;<br>        next = n.right<br>        n.right = pre<br>        pre = n<br>        n = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;<br><br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/solution/shen-du-yan-du-di-gui-die-dai-qian-zhong-nucl/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>递归</tag>
      
      <tag>迭代</tag>
      
      <tag>前序</tag>
      
      <tag>中序</tag>
      
      <tag>后序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣746 使用最小花费爬楼梯</title>
    <link href="/2020/12/21/%E5%8A%9B%E6%89%A3746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
    <url>/2020/12/21/%E5%8A%9B%E6%89%A3746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值cost[i](索引从零开始)。  </p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><p>示例 1:<br>输入: cost = [10, 15, 20]<br>输出: 15<br>解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。  </p><p>示例 2:<br>输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>输出: 6<br>解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。  </p><p>注意：<br>cost 的长度将会在 [2, 1000]。<br>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs">https://leetcode-cn.com/problems/min-cost-climbing-stairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>就动态规划再记忆化，今天的比较简单，等中午小宇题解出来看看有没有更好的方法</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">cost</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> d(cost,cost.length);<br>&#125;;<br><span class="hljs-keyword">var</span> d = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost,i</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> a=[];<br>    a[<span class="hljs-number">0</span>]=a[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">2</span>;j&lt;=i;j++)&#123;<br>         a[j]=<span class="hljs-built_in">Math</span>.min(a[j-<span class="hljs-number">2</span>]+cost j-<span class="hljs-number">2</span>],a[j-<span class="hljs-number">1</span>]+cost[j-<span class="hljs-number">1</span>])<br>        &#125;<br>    <span class="hljs-keyword">return</span> a[i];<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-递归"><a href="#一-递归" class="headerlink" title="一 递归"></a>一 递归</h4><p>解题思路<br>从0或1，每轮2分支：进1或进2。递归模拟过程直至越界。回溯累加成本取最小值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost</span>) </span>&#123;<br>    d = <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i &gt;= cost.length ? <span class="hljs-number">0</span> : cost[i] + <span class="hljs-built_in">Math</span>.min(d(i + <span class="hljs-number">1</span>), d(i + <span class="hljs-number">2</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(d(<span class="hljs-number">0</span>), d(<span class="hljs-number">1</span>))<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/min-cost-climbing-stairs/solution/di-gui-dong-tai-gui-hua-zhuang-tai-ji-1x-rrca/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br><br></code></pre></td></tr></table></figure><h4 id="1-2-递归-·-剪枝"><a href="#1-2-递归-·-剪枝" class="headerlink" title="1.2 递归 · 剪枝"></a>1.2 递归 · 剪枝</h4><p>解题思路<br>索引相同，后面成本相同。深度优先遍历到左分支到底，回溯时，缓存索引对应后面成本<br>再次递归到相同索引，不再递归，后面成本直接取缓存。即构造以索引为键名的缓存函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>；<br><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> h = <span class="hljs-built_in">Array</span>(cost.length)<br>    d = <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i &gt;= cost.length ? <span class="hljs-number">0</span> : h[i] === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? h[i] = cost[i] + <span class="hljs-built_in">Math</span>.min(d(i + <span class="hljs-number">1</span>), d(i + <span class="hljs-number">2</span>)) : h[i]<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(d(<span class="hljs-number">0</span>), d(<span class="hljs-number">1</span>))<br>&#125;;<br><br><span class="hljs-built_in">Array</span> <span class="hljs-number">1</span>行代码；<br><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost, h = <span class="hljs-built_in">Array</span>(cost.length), i = -<span class="hljs-number">1</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> i &gt;= cost.length ? <span class="hljs-number">0</span> : h[i] === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? h[i] = (i === - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : cost[i]) + <span class="hljs-built_in">Math</span>.min(minCostClimbingStairs(cost, h, i + <span class="hljs-number">1</span>), minCostClimbingStairs(cost, h, i + <span class="hljs-number">2</span>)) : h[i]<br>&#125;;<br><br><span class="hljs-built_in">Object</span>；<br><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> h = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>    d = <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i &gt;= cost.length ? <span class="hljs-number">0</span> : h[i] === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? h[i] = cost[i] + <span class="hljs-built_in">Math</span>.min(d(i + <span class="hljs-number">1</span>), d(i + <span class="hljs-number">2</span>)) : h[i]<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(d(<span class="hljs-number">0</span>), d(<span class="hljs-number">1</span>))<br>&#125;;<br><br><span class="hljs-built_in">Map</span>；<br><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span><br>    d = <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i &gt;= cost.length ? <span class="hljs-number">0</span> : (!h.has(i) &amp;&amp; h.set(i, cost[i] + <span class="hljs-built_in">Math</span>.min(d(i + <span class="hljs-number">1</span>), d(i + <span class="hljs-number">2</span>))), h.get(i))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(d(<span class="hljs-number">0</span>), d(<span class="hljs-number">1</span>))<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/min-cost-climbing-stairs/solution/di-gui-dong-tai-gui-hua-zhuang-tai-ji-1x-rrca/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-动态规划"><a href="#二-动态规划" class="headerlink" title="二 动态规划"></a>二 动态规划</h4><p>2.1 到达成本<br>解题思路<br>dp[i]到达i成本，dp = [0, 0]，从0到cost.length + 1，dp[cost.length]即解<br>dp[i] = (dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])取小  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(cost.length + <span class="hljs-number">1</span>), i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(i++ &lt; cost.length) <br>        dp[i] = <span class="hljs-built_in">Math</span>.min(dp[i - <span class="hljs-number">2</span>] + cost[i - <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>] + cost[i - <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> dp[i - <span class="hljs-number">1</span>]<br>&#125;;<br><br>Reduce <span class="hljs-number">1</span>行代码；<br><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> cost.concat(<span class="hljs-number">0</span>).reduce(<span class="hljs-function">(<span class="hljs-params">dp, _, i, a</span>) =&gt;</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; (dp[i] = <span class="hljs-built_in">Math</span>.min(dp[i - <span class="hljs-number">2</span>] + a[i - <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>])), dp), <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(cost.length + <span class="hljs-number">1</span>))[cost.length]<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/min-cost-climbing-stairs/solution/di-gui-dong-tai-gui-hua-zhuang-tai-ji-1x-rrca/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="2-2-出发成本"><a href="#2-2-出发成本" class="headerlink" title="2.2 出发成本"></a>2.2 出发成本</h4><p>解题思路<br>dp[i]从i出发成本，dp = [cost[0], cost[1]]，从0到cost.length，到终点前<br>从1步前或2步前出发。(dp[cost.length - 2], dp[cost.length - 1])取小即解<br>dp[i] = cost[i] + (dp[i - 1], dp[i - 2])取小</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> dp = [cost[<span class="hljs-number">0</span>], cost[<span class="hljs-number">1</span>]], i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; cost.length) <br>        dp[i] = cost[i] + <span class="hljs-built_in">Math</span>.min(dp[i - <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(dp[i - <span class="hljs-number">2</span>], dp[i - <span class="hljs-number">1</span>])<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/min-cost-climbing-stairs/solution/di-gui-dong-tai-gui-hua-zhuang-tai-ji-1x-rrca/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="三-状态机"><a href="#三-状态机" class="headerlink" title="三 状态机"></a>三 状态机</h4><p>3.1 到达成本<br>解题思路<br>降维动态规划：当前到达成本只与上一个和上上一个有关<br>cur表示当前到达成本，代替dp[i]。赋值前的cur代替dp[i - 1]<br>prev记录赋值前的cur，代替dp[i - 2]  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> prev = cur = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(i++ &lt; cost.length) &#123;<br>        <span class="hljs-keyword">let</span> tmp = <span class="hljs-built_in">Math</span>.min(prev + cost[i - <span class="hljs-number">2</span>], cur + cost[i - <span class="hljs-number">1</span>])<br>        prev = cur<br>        cur = tmp<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/min-cost-climbing-stairs/solution/di-gui-dong-tai-gui-hua-zhuang-tai-ji-1x-rrca/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="3-2-出发成本"><a href="#3-2-出发成本" class="headerlink" title="3.2 出发成本"></a>3.2 出发成本</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> minCostClimbingStairs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cost</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> prev = cost[<span class="hljs-number">0</span>], cur = cost[<span class="hljs-number">1</span>], i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; cost.length) &#123;<br>        <span class="hljs-keyword">let</span> tmp = cost[i] + <span class="hljs-built_in">Math</span>.min(prev, cur)<br>        prev = cur<br>        cur = tmp<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(prev, cur)<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/min-cost-climbing-stairs/solution/di-gui-dong-tai-gui-hua-zhuang-tai-ji-1x-rrca/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>动态规划</tag>
      
      <tag>状态机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣316 去除重复字母</title>
    <link href="/2020/12/20/%E5%8A%9B%E6%89%A3316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/"/>
    <url>/2020/12/20/%E5%8A%9B%E6%89%A3316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。<br>示例 1：</p><p>输入：s = “bcabc”<br>输出：”abc”  </p><p>示例 2：<br>输入：s = “cbacdcbc”<br>输出：”acdb” </p><p>提示：</p><p>1 &lt;= s.length &lt;= 104<br>s 由小写英文字母组成</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicate-letters">https://leetcode-cn.com/problems/remove-duplicate-letters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-哈希表-栈"><a href="#一-哈希表-栈" class="headerlink" title="一 哈希表 + 栈"></a>一 哈希表 + 栈</h4><p><a href="https://imgchr.com/i/raaSVP"><img src="https://s3.ax1x.com/2020/12/20/raaSVP.png" alt="raaSVP.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>:<br><span class="hljs-keyword">var</span> removeDuplicateLetters = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> counts = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">26</span>), stack = [], i = s.length<br>    <span class="hljs-keyword">while</span> (i--) counts[s.charCodeAt(i) - <span class="hljs-number">97</span>]++<br>    <span class="hljs-keyword">while</span> (++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> n = s.charCodeAt(i)<br>        counts[n - <span class="hljs-number">97</span>]--<br>        <span class="hljs-keyword">if</span> (stack.includes(n) === <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">let</span> j = stack.length<br>            <span class="hljs-keyword">while</span>(j-- &amp;&amp; stack[j] &gt; n &amp;&amp; counts[stack[j] - <span class="hljs-number">97</span>]) stack.pop()<br>            stack.push(n)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(...stack)<br>&#125;;<br><span class="hljs-string">``</span><span class="hljs-string">`        </span><br><span class="hljs-string">  </span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>javascript<br>双<span class="hljs-built_in">Array</span>：第二个<span class="hljs-built_in">Array</span>缓存元素是否已在栈中代替includes<br><span class="hljs-keyword">var</span> removeDuplicateLetters = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> counts = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">26</span>), stack = [], i = s.length, has = counts.slice()<br>    <span class="hljs-keyword">while</span> (i--) counts[s.charCodeAt(i) - <span class="hljs-number">97</span>]++<br>    <span class="hljs-keyword">while</span> (++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> n = s.charCodeAt(i), index = n - <span class="hljs-number">97</span><br>        counts[index]--<br>        <span class="hljs-keyword">if</span> (has[index] === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">let</span> j = stack.length<br>            <span class="hljs-keyword">while</span>(j-- &amp;&amp; stack[j] &gt; n &amp;&amp; counts[stack[j] - <span class="hljs-number">97</span>]) <br>                has[stack.pop() - <span class="hljs-number">97</span>] = <span class="hljs-number">0</span><br>            stack.push(n)<br>            has[index] = <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(...stack)<br>&#125;;<br><br><span class="hljs-built_in">Map</span>:<br><span class="hljs-keyword">var</span> removeDuplicateLetters = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> counts = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, stack = [], i = s.length<br>    <span class="hljs-keyword">while</span> (i--) counts.set(s[i], counts.has(s[i]) ? counts.get(s[i]) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">while</span> (++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> n = s[i]<br>        counts.set(n, counts.get(n) - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> (stack.includes(n) === <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">let</span> j = stack.length<br>            <span class="hljs-keyword">while</span>(j-- &amp;&amp; stack[j] &gt; n &amp;&amp; counts.get(stack[j])) stack.pop()<br>            stack.push(n)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.join(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/remove-duplicate-letters/solution/ha-xi-biao-shu-zu-zhan-5xing-dai-ma-2jie-ttcd/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-数组-栈"><a href="#二-数组-栈" class="headerlink" title="二 数组 + 栈"></a>二 数组 + 栈</h4><p>解题思路<br>哈希表仅为判断后面有没有栈顶字符，并不关心有多少<br>includes和indexOf第二个参数fromIndex，可判断从指定位及以后是否包含</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript">includes:<br><span class="hljs-keyword">var</span> removeDuplicateLetters = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> stack = [], i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> n = s[i]<br>        <span class="hljs-keyword">if</span> (stack.includes(n) === <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">let</span> j = stack.length<br>            <span class="hljs-keyword">while</span>(j-- &amp;&amp; stack[j] &gt; n &amp;&amp; s.includes(stack[j], i)) stack.pop()<br>            stack.push(n)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.join(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;;<br><br>includes · 无中间变量：n和j可删:<br><span class="hljs-keyword">var</span> removeDuplicateLetters = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> stack = [], i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">if</span> (stack.includes(s[i])) <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">while</span>(stack.length &amp;&amp; stack[stack.length - <span class="hljs-number">1</span>] &gt; s[i] &amp;&amp; s.includes(stack[stack.length - <span class="hljs-number">1</span>], i)) stack.pop()<br>        stack.push(s[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.join(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;;<br><br>indexOf:<br><span class="hljs-keyword">var</span> removeDuplicateLetters = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> stack = [], i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">const</span> n = s[i]<br>        <span class="hljs-keyword">if</span> (stack.indexOf(n) === -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">let</span> j = stack.length<br>            <span class="hljs-keyword">while</span>(j-- &amp;&amp; stack[j] &gt; n &amp;&amp; s.indexOf(stack[j], i) &gt; -<span class="hljs-number">1</span>) stack.pop()<br>            stack.push(n)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.join(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;;<br><br>indexOf · 无中间变量：n和j可删<br><span class="hljs-keyword">var</span> removeDuplicateLetters = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> stack = [], i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">if</span> (stack.indexOf(s[i]) &gt; -<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">while</span>(stack.length &amp;&amp; stack[stack.length - <span class="hljs-number">1</span>] &gt; s[i] &amp;&amp; s.indexOf(stack[stack.length - <span class="hljs-number">1</span>], i) &gt; -<span class="hljs-number">1</span>) stack.pop()<br>        stack.push(s[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.join(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/remove-duplicate-letters/solution/ha-xi-biao-shu-zu-zhan-5xing-dai-ma-2jie-ttcd/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
      <tag>数组</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣48 旋转图像</title>
    <link href="/2020/12/19/%E5%8A%9B%E6%89%A348-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2020/12/19/%E5%8A%9B%E6%89%A348-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p>示例 1:</p><p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],  </p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]  </p><p>示例 2:<br>给定 matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p><p>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rotate-image">https://leetcode-cn.com/problems/rotate-image</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-倒序遍历-·-深拷贝：新-→-原"><a href="#一-倒序遍历-·-深拷贝：新-→-原" class="headerlink" title="一 倒序遍历 · 深拷贝：新 → 原"></a>一 倒序遍历 · 深拷贝：新 → 原</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.from + slice：<br><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = matrix.length, m = <span class="hljs-built_in">Array</span>.from(&#123;<span class="hljs-attr">length</span>: n&#125;, <span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> matrix[i].slice())<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n; i--;) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = n; j--;) <br>            matrix[i][j] = m[n - <span class="hljs-number">1</span> - j][i]<br>&#125;;<br><br><span class="hljs-built_in">JSON</span>.stringify + <span class="hljs-built_in">JSON</span>.parse：<br><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matrix</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = matrix.length, m = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(matrix))<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n; i--;) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = n; j--;) <br>            matrix[i][j] = m[n - <span class="hljs-number">1</span> - j][i]<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/rotate-image/solution/luo-xuan-kao-bei-xuan-zhuan-fan-zhuan-7x-5v91/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="二-顺序遍历-·-拷贝：原-→-新-→-原"><a href="#二-顺序遍历-·-拷贝：原-→-新-→-原" class="headerlink" title="二 顺序遍历 · 拷贝：原 → 新 → 原"></a>二 顺序遍历 · 拷贝：原 → 新 → 原</h4><p>解题思路<br>任意顺序遍历矩阵，新矩阵[j, n - 1 - j] = 原矩阵坐标[i, j]值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = matrix.length, m = <span class="hljs-built_in">Array</span>.from(&#123;<span class="hljs-attr">length</span>: n&#125;, <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">Array</span>(n))<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            m[j][n - <span class="hljs-number">1</span> - i] = matrix[i][j]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            matrix[i][j] = m[i][j]<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/rotate-image/solution/luo-xuan-kao-bei-xuan-zhuan-fan-zhuan-7x-5v91/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="三-倒序垂直扫描-·-队列"><a href="#三-倒序垂直扫描-·-队列" class="headerlink" title="三 倒序垂直扫描 · 队列"></a>三 倒序垂直扫描 · 队列</h4><p><a href="https://imgchr.com/i/radpLR"><img src="https://s3.ax1x.com/2020/12/20/radpLR.png" alt="radpLR.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = matrix.length, queue = []<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) <br>            queue.push(matrix[i][j])<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = n; j--;) <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>            matrix[i][j] = queue.shift()<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/rotate-image/solution/luo-xuan-kao-bei-xuan-zhuan-fan-zhuan-7x-5v91/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="四-层次遍历-·-旋转"><a href="#四-层次遍历-·-旋转" class="headerlink" title="四 层次遍历 · 旋转"></a>四 层次遍历 · 旋转</h4><p>每旋转1格，上 右 下 左四格值，存1换4<br>第0层：0 ~ n - 1<br>第1层：1 ~ n - 1 - 1<br>…<br>直到第n / 2取整层：i ~ n - 1 - i<br><a href="https://imgchr.com/i/radMwt"><img src="https://s3.ax1x.com/2020/12/20/radMwt.png" alt="radMwt.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = matrix.length<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n &gt;&gt; <span class="hljs-number">1</span>; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = i; j &lt; n - <span class="hljs-number">1</span> - i; j++) &#123;<br>            <span class="hljs-keyword">let</span> tmp = matrix[i][j]<br>            matrix[i][j] = matrix[n - <span class="hljs-number">1</span> - j][i]<br>            matrix[n - <span class="hljs-number">1</span> - j][i] = matrix[n - <span class="hljs-number">1</span> - i][n - <span class="hljs-number">1</span> - j]<br>            matrix[n - <span class="hljs-number">1</span> - i][n - <span class="hljs-number">1</span> -j] = matrix[j][n - <span class="hljs-number">1</span> - i]<br>            matrix[j][n - <span class="hljs-number">1</span> - i] = tmp<br>        &#125;<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/rotate-image/solution/luo-xuan-kao-bei-xuan-zhuan-fan-zhuan-7x-5v91/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="五-翻转"><a href="#五-翻转" class="headerlink" title="五 翻转"></a>五 翻转</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = matrix.length<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n &gt;&gt; <span class="hljs-number">1</span>; j++) <br>            [matrix[i][n - <span class="hljs-number">1</span> - j], matrix[i][j]] = [matrix[i][j], matrix[i][n - <span class="hljs-number">1</span> - j]]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n - <span class="hljs-number">1</span> - i; j++)<br>            [matrix[n - <span class="hljs-number">1</span> - j][n - <span class="hljs-number">1</span> - i], matrix[i][j]] = [matrix[i][j], matrix[n - <span class="hljs-number">1</span> - j][n - <span class="hljs-number">1</span> - i]]<br>&#125;;<br><br>中间变量：<br><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = matrix.length, tmp, i, j<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n &gt;&gt; <span class="hljs-number">1</span>; j++) &#123;<br>            tmp = matrix[i][j]<br>            matrix[i][j] = matrix[i][n - <span class="hljs-number">1</span> - j]<br>            matrix[i][n - <span class="hljs-number">1</span> - j] = tmp<br>        &#125;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n - <span class="hljs-number">1</span> - i; j++) &#123;<br>            tmp = matrix[i][j]<br>            matrix[i][j] = matrix[n - <span class="hljs-number">1</span> - j][n - <span class="hljs-number">1</span> - i]<br>            matrix[n - <span class="hljs-number">1</span> - j][n - <span class="hljs-number">1</span> - i] = tmp<br>        &#125;<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/rotate-image/solution/luo-xuan-kao-bei-xuan-zhuan-fan-zhuan-7x-5v91/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="六-螺旋遍历-·-队列"><a href="#六-螺旋遍历-·-队列" class="headerlink" title="六 螺旋遍历 · 队列"></a>六 螺旋遍历 · 队列</h4><p>解题思路<br>螺旋遍历矩阵，方向d → ↓ ← ↑循环<br>初始边界b[上，右，左，下] = [1, n - 1, 0, n - 1]<br>初始位置i = 0 j = 0，遍历格数k = 0，直到k = n * n - 1所有格遍历完<br>→ j++ 到右边界转↓，i++，右边界收缩-1<br>↓ i++ 到下边界转←，j–，下边界收缩-1<br>← j– 到左边界转↑，i–，左边界收缩+1<br>↑ i– 到上边界转→，j++，上边界收缩+1<br>队列queue 放入遍历过的值<br>→ 留空。到右边界时，弹出赋值<br>↑ 弹出赋值<br>← 弹出赋值 到左边界，如[[1, 2], [3, 4]]，判断到3已到头，填空<br>↑ 弹出赋值 到上边界，如[[1, 2, 3],[4, 5, 6],[7, 8, 9]]，到5已到头，填空  </p><p><a href="https://imgchr.com/i/radDYT"><img src="https://s3.ax1x.com/2020/12/20/radDYT.png" alt="radDYT.png"></a><br><a href="https://imgchr.com/i/radJSg"><img src="https://s3.ax1x.com/2020/12/20/radJSg.png" alt="radJSg.png"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs javascript">碰撞转向:<br><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = matrix.length, queue = []<br>    <span class="hljs-keyword">let</span> k = -<span class="hljs-number">1</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, b = [<span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>], d = <span class="hljs-string">&#x27;→&#x27;</span><br>    <span class="hljs-keyword">while</span>(++k &lt; n * n) &#123;<br>        queue.push(matrix[i][j])<br>        <span class="hljs-keyword">switch</span>(d) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;→&#x27;</span>:<br>                <span class="hljs-keyword">if</span> (j &lt; b[<span class="hljs-number">1</span>]) j++<br>                <span class="hljs-keyword">else</span> &#123;<br>                    matrix[i][j] = queue.shift()<br>                    i++<br>                    d = <span class="hljs-string">&#x27;↓&#x27;</span><br>                    b[<span class="hljs-number">1</span>]--<br>                &#125;<br>            <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;↓&#x27;</span>:<br>                matrix[i][j] = queue.shift()<br>                <span class="hljs-keyword">if</span> (i &lt; b[<span class="hljs-number">3</span>]) i++<br>                <span class="hljs-keyword">else</span> &#123;<br>                    j--<br>                    d = <span class="hljs-string">&#x27;←&#x27;</span><br>                    b[<span class="hljs-number">3</span>]--<br>                &#125;<br>            <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;←&#x27;</span>:<br>                matrix[i][j] = queue.shift()<br>                <span class="hljs-keyword">if</span> (j &gt; b[<span class="hljs-number">2</span>]) j--<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (k + <span class="hljs-number">1</span> === n * n) &#123;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> p = j; p &lt;= b[<span class="hljs-number">1</span>]; p++) <br>                            matrix[b[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>][p] = queue.shift()<br>                    &#125;<br>                    i--<br>                    d = <span class="hljs-string">&#x27;↑&#x27;</span><br>                    b[<span class="hljs-number">2</span>]++<br>                &#125;<br>            <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;↑&#x27;</span>:<br>                matrix[i][j] = queue.shift()<br>                <span class="hljs-keyword">if</span> (i &gt; b[<span class="hljs-number">0</span>]) i--<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> p = j; p &lt;= b[<span class="hljs-number">1</span>]; p++) <br>                        matrix[b[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>][p] = queue.shift()<br>                    j++<br>                    d = <span class="hljs-string">&#x27;→&#x27;</span><br>                    b[<span class="hljs-number">0</span>]++<br>                &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br>循环:<br><span class="hljs-keyword">var</span> rotate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> n = matrix.length, queue = []<br>    <span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>, b = n - <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>, i <span class="hljs-comment">// 边界：t上 r右 l左 b下</span><br>    <span class="hljs-keyword">while</span>(k &lt; n * n)&#123;<br>        <span class="hljs-keyword">for</span>(i = l; i &lt;= r; i++) &#123; <span class="hljs-comment">// →</span><br>            k++<br>            queue.push(matrix[t][i])<br>            <span class="hljs-keyword">if</span> (i === r) matrix[t][i] = queue.shift()<br>        &#125;<br>        t++<br>        <span class="hljs-keyword">for</span>(i = t; i &lt;= b; i++) &#123; <span class="hljs-comment">// ↓</span><br>            k++<br>            queue.push(matrix[i][r])<br>            matrix[i][r] = queue.shift()<br>        &#125;<br>        r--<br>        <span class="hljs-keyword">for</span>(i = r; i &gt;= l; i--) &#123; <span class="hljs-comment">// ←</span><br>            k++<br>            queue.push(matrix[b][i])<br>            matrix[b][i] = queue.shift()<br>            <span class="hljs-keyword">if</span> (i === l &amp;&amp; k === n * n) <br>                <span class="hljs-keyword">while</span>(queue.length) <br>                    matrix[t - <span class="hljs-number">1</span>][l++] = queue.shift()<br>        &#125;<br>        b--<br>        <span class="hljs-keyword">for</span>(i = b; i &gt;= t; i--) &#123; <span class="hljs-comment">// ↑</span><br>            k++<br>            queue.push(matrix[i][l])<br>            matrix[i][l] = queue.shift()<br>            <span class="hljs-keyword">if</span> (i === t) &#123;<br>                <span class="hljs-keyword">let</span> _l = l<br>                <span class="hljs-keyword">while</span>(queue.length) <br>                    matrix[t - <span class="hljs-number">1</span>][_l++] = queue.shift()<br>            &#125;<br>        &#125;<br>        l++<br>    &#125;<br>    <span class="hljs-keyword">return</span> queue<br>&#125;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/rotate-image/solution/luo-xuan-kao-bei-xuan-zhuan-fan-zhuan-7x-5v91/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>队列</tag>
      
      <tag>深拷贝</tag>
      
      <tag>螺旋</tag>
      
      <tag>旋转</tag>
      
      <tag>翻转</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣389 找不同</title>
    <link href="/2020/12/18/%E5%8A%9B%E6%89%A3389-%E6%89%BE%E4%B8%8D%E5%90%8C/"/>
    <url>/2020/12/18/%E5%8A%9B%E6%89%A3389-%E6%89%BE%E4%B8%8D%E5%90%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 s 和 t，它们只包含小写字母。</p><p>字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 t 中被添加的字母。</p><p> </p><p>示例 1：</p><p>输入：s = “abcd”, t = “abcde”<br>输出：”e”<br>解释：’e’ 是那个被添加的字母。</p><p>示例 2：<br>输入：s = “”, t = “y”<br>输出：”y”  </p><p>示例 3：<br>输入：s = “a”, t = “aa”<br>输出：”a”  </p><p>示例 4：<br>输入：s = “ae”, t = “aea”<br>输出：”a” </p><p>提示：</p><p>0 &lt;= s.length &lt;= 1000<br>t.length == s.length + 1<br>s 和 t 只包含小写字母  </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-the-difference">https://leetcode-cn.com/problems/find-the-difference</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接两个字符串转为数组然后排序遍历比较即可（今天被宇哥拒绝转载了挺失望的只能设密码自己看了）</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="个人题解"><a href="#个人题解" class="headerlink" title="个人题解"></a>个人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">t</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;character&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a=s.split(<span class="hljs-string">&quot;&quot;</span>).sort(),b=t.split(<span class="hljs-string">&quot;&quot;</span>).sort();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]!==b[i])&#123;<br>            <span class="hljs-keyword">return</span> b[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b[b.length-<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>, r = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length) r ^= s.charCodeAt(i) ^ t.charCodeAt(i)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(r ^ t.charCodeAt(i))<br>&#125;;<br><br>Reduce:<br><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode((s + t).split(<span class="hljs-string">&#x27;&#x27;</span>).reduce(<span class="hljs-function">(<span class="hljs-params">p, v</span>) =&gt;</span> p ^ v.charCodeAt(), <span class="hljs-number">0</span>))<br>&#125;;<br><br><br>左移<span class="hljs-number">1</span>：<br>每次bit = bit ^ <span class="hljs-number">1</span>左移字符Unicode编码 - <span class="hljs-number">97</span>位。剩余<span class="hljs-number">1</span>在第几位，+ <span class="hljs-number">97</span>还原字符<br><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> bit = <span class="hljs-number">0</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; s.length) bit ^= <span class="hljs-number">1</span> &lt;&lt; (s.charCodeAt(i) - <span class="hljs-number">97</span>)<br>    i++<br>    <span class="hljs-keyword">while</span> (i--) bit ^= <span class="hljs-number">1</span> &lt;&lt; (t.charCodeAt(i) - <span class="hljs-number">97</span>)<br>    <span class="hljs-keyword">while</span> (bit &gt;&gt;= <span class="hljs-number">1</span>) i++<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(i + <span class="hljs-number">98</span>)<br>&#125;;<br><br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/find-the-difference/solution/wei-ji-shu-wei-yi-lei-jia-ti-huan-sort1x-s0li/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>解题思路<br>遍历字符串，统计出现次数。一轮+，一轮-。先谁，顺序，增减规则随意，开心就好<br>第二轮遍历，返回出现次数不能回到0的字符（示例增减绝对值相同为1）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>:<br><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(<span class="hljs-number">26</span>) <span class="hljs-comment">// Init8Array(26)可过测试用例</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length) h[s.charCodeAt(i) - <span class="hljs-number">97</span>]++<br>    i++<br>    <span class="hljs-keyword">while</span>(i--) <span class="hljs-keyword">if</span> (--h[t.charCodeAt(i) - <span class="hljs-number">97</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> t[i]<br>&#125;;<br><br><span class="hljs-built_in">Object</span>:<br><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>, h = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">while</span>(++i &lt; s.length) h[s[i]] ? h[s[i]]++ : h[s[i]] = <span class="hljs-number">1</span><br>    i++<br>    <span class="hljs-keyword">while</span>(i--) <span class="hljs-keyword">if</span> (h[t[i]] === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> || --h[t[i]] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> t[i]<br>&#125;;<br><br><span class="hljs-built_in">Map</span>:<br><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, tmp<br>    <span class="hljs-keyword">while</span>(++i &lt; s.length) h.set(s[i], h.has(s[i]) ? h.get(s[i]) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>)<br>    i++<br>    <span class="hljs-keyword">while</span>(i--) <span class="hljs-keyword">if</span> (!h.has(t[i]) || (h.set(t[i], tmp = h.get(t[i]) - <span class="hljs-number">1</span>), tmp &lt; <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> t[i]<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/find-the-difference/solution/wei-ji-shu-wei-yi-lei-jia-ti-huan-sort1x-s0li/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="唯一"><a href="#唯一" class="headerlink" title="唯一"></a>唯一</h4><p>解题思路<br>找一个容器，不能同时放两个相同元素。遇已有，删已有。没有放。只有解留在容器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>:值最多<span class="hljs-number">1</span>。遇字符Unicode编码 - <span class="hljs-number">97</span>对应值已= <span class="hljs-number">1</span>时，值<span class="hljs-number">0</span>。没有+<span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(<span class="hljs-number">26</span>)<br>    <span class="hljs-keyword">while</span>(++i &lt; t.length) d(h, t.charCodeAt(i) - <span class="hljs-number">97</span>)<br>    i--<br>    <span class="hljs-keyword">while</span>(i--) d(h, s.charCodeAt(i) - <span class="hljs-number">97</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(h.findIndex(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v === <span class="hljs-number">1</span>) + <span class="hljs-number">97</span>)<br>&#125;;<br><span class="hljs-keyword">var</span> d = <span class="hljs-function">(<span class="hljs-params">h, k</span>) =&gt;</span> h[k] ? h[k]-- : h[k]++<br><br><span class="hljs-built_in">Set</span>:<br><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span><br>    <span class="hljs-keyword">while</span>(++i &lt; t.length) d(h, t[i])<br>    i--<br>    <span class="hljs-keyword">while</span>(i--) d(h, s[i])<br>    <span class="hljs-keyword">return</span> h.values().next().value<br>&#125;;<br><span class="hljs-keyword">var</span> d = <span class="hljs-function">(<span class="hljs-params">h, k</span>) =&gt;</span> h.has(k) ? h.delete(k) : h.add(k)<br><br><span class="hljs-attr">Object</span>:<br><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>, h = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">while</span>(++i &lt; t.length) d(h, t[i])<br>    i--<br>    <span class="hljs-keyword">while</span>(i--) d(h, s[i])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(h)[<span class="hljs-number">0</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> d = <span class="hljs-function">(<span class="hljs-params">h, k</span>) =&gt;</span> h[k] ? <span class="hljs-keyword">delete</span> h[k] : h[k] = <span class="hljs-number">1</span><br><br><span class="hljs-attr">Map</span>:<br><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span><br>    <span class="hljs-keyword">while</span>(++i &lt; t.length) d(h, t[i])<br>    i--<br>    <span class="hljs-keyword">while</span>(i--) d(h, s[i])<br>    <span class="hljs-keyword">return</span> h.keys().next().value<br>&#125;;<br><span class="hljs-keyword">var</span> d = <span class="hljs-function">(<span class="hljs-params">h, k</span>) =&gt;</span> h.has(k) ? h.delete(k) : h.set(k, <span class="hljs-number">1</span>)<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/find-the-difference/solution/wei-ji-shu-wei-yi-lei-jia-ti-huan-sort1x-s0li/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="累加"><a href="#累加" class="headerlink" title="累加"></a>累加</h4><p>解题思路<br>遍历字符串，先累加字符的Unicode编码，再累减。差值绝对值即解的Unicode编码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span>, r = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(++i &lt; t.length) r += t.charCodeAt(i)<br>    i--<br>    <span class="hljs-keyword">while</span>(i--) r -= s.charCodeAt(i)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode(r)<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/find-the-difference/solution/wei-ji-shu-wei-yi-lei-jia-ti-huan-sort1x-s0li/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>解题思路<br>遍历短字符串，将长字符串的对应字符替换为空。返回长字符串剩余字符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt; s.length; i++) t = t.replace(s[i], <span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">return</span> t<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/find-the-difference/solution/wei-ji-shu-wei-yi-lei-jia-ti-huan-sort1x-s0li/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findTheDifference = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a, n = <span class="hljs-number">0</span>, tmp = (s + t).split(<span class="hljs-string">&#x27;&#x27;</span>).sort(), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; tmp.length) <br>        <span class="hljs-keyword">if</span> (a) <br>            <span class="hljs-keyword">if</span> (a === tmp[i]) n++<br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-keyword">if</span> ((n &amp; <span class="hljs-number">1</span>) === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a<br>                <span class="hljs-keyword">else</span> &#123;<br>                    a = tmp[i]<br>                    n = <span class="hljs-number">0</span><br>                &#125;<br>        <span class="hljs-keyword">else</span> a = tmp[i]<br>    <span class="hljs-keyword">return</span> a<br>&#125;;<br><br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/find-the-difference/solution/wei-ji-shu-wei-yi-lei-jia-ti-huan-sort1x-s0li/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>直接异或最快，Redcue等需字符串转数组影响性能<br>左移1解法中^改为&amp;可用于[0, 32)位数字及数字表示的小写字母，大写字母验重<br>计数排序首选包含默认值的数组，短路h[key] = (h[key] || 0) + 1这样写简洁，但是<br>影响性能<br>h[key]为+0 -0 false null NaN等非undefined假值时，也会短路<br>ES2020提供的空值合并运算符 ??将返回第一个已定义值是未来的更佳选择<br>唯一解法频繁增删，影响性能。相比之下，计数的赋值操作稍快<br>累加解法中，还可用质数累乘，甚至自建字符对应哈希表来求差或商<br>对于短字符串，replace原生优势 &gt; Object和Map哈希表开销  </p>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计数</tag>
      
      <tag>位运算</tag>
      
      <tag>字符串</tag>
      
      <tag>唯一</tag>
      
      <tag>累加</tag>
      
      <tag>替换</tag>
      
      <tag>Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣714 买卖股票的最佳时机含手续费</title>
    <link href="/2020/12/17/%E5%8A%9B%E6%89%A3714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/"/>
    <url>/2020/12/17/%E5%8A%9B%E6%89%A3714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p>示例 1:</p><p>输入: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出: 8<br>解释: 能够达到的最大利润:<br>在此处买入 prices[0] = 1<br>在此处卖出 prices[3] = 8<br>在此处买入 prices[4] = 4<br>在此处卖出 prices[5] = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.<br>注意:  </p><p>0 &lt; prices.length &lt;= 50000.<br>0 &lt; prices[i] &lt; 50000.<br>0 &lt;= fee &lt; 50000. </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>后面补的嘻嘻，看了一下动态规划的思路模仿用动态机写的，自己推的时候一直没推出来这关系┭┮﹏┭┮</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">prices</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">fee</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> d0=<span class="hljs-number">0</span>,d1=-prices[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;prices.length;i++)&#123;<br>        <span class="hljs-keyword">let</span> t=d0;<br>        d0=<span class="hljs-built_in">Math</span>.max(d0,d1+prices[i]-fee);<br>        d1=<span class="hljs-built_in">Math</span>.max(d1,t-prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> d0;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-递归"><a href="#一-递归" class="headerlink" title="一 递归"></a>一 递归</h4><p>解题思路<br>状态s：true有股票，false无股票。手续费卖出时扣除<br>true，有股票时的最大利润 = 以下两者取大<br>持有。利润不变<br>卖出。利润 = 利润 + 股票价格 - 手续费。有股票 → 无股票<br>false，无股票时的最大利润 = 以下两者取大<br>观望。利润不变<br>买入。利润 = 利润 - 股票价格。无股票 → 有股票<br>最大利润 = 有股票时的最大利润 和 无股票时的最大利润 取大  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">超时：<br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<br>    d = <span class="hljs-function">(<span class="hljs-params">s, i</span>) =&gt;</span> i === prices.length  ? <span class="hljs-number">0</span> :<br>                  s ? <span class="hljs-built_in">Math</span>.max(d(s, i + <span class="hljs-number">1</span>), d(<span class="hljs-literal">false</span>, i + <span class="hljs-number">1</span>) + prices[i] - fee) :<br>                      <span class="hljs-built_in">Math</span>.max(d(s, i + <span class="hljs-number">1</span>), d(<span class="hljs-literal">true</span> , i + <span class="hljs-number">1</span>) - prices[i])<br>    <span class="hljs-keyword">return</span> d(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>&#125;;<br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/di-gui-dong-tai-gui-hua-tan-xin-suan-fa-7wk97/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="递归-剪枝"><a href="#递归-剪枝" class="headerlink" title="递归 剪枝"></a>递归 剪枝</h4><p>解题思路<br>以递归函数的变化的形参：i与s作键名，构造缓存函数<br>i &lt;= 数组长度，状态s为布尔值<br>true： 取i<br>false：取数组长度 + i<br>得到的键名唯一，比i + , + s更充分利用空间  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>：<br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> len = prices.length, h = <span class="hljs-built_in">Array</span>(len * <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">let</span> t<br>    d = <span class="hljs-function">(<span class="hljs-params">s, i</span>) =&gt;</span> i === len  ? <span class="hljs-number">0</span> : <br>                  h[t = s ? i : len + i] !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? h[t] : h[t] = <br>                  (s ? <span class="hljs-built_in">Math</span>.max(d(s, i + <span class="hljs-number">1</span>), d(<span class="hljs-literal">false</span>, i + <span class="hljs-number">1</span>) + prices[i] - fee) :<br>                       <span class="hljs-built_in">Math</span>.max(d(s, i + <span class="hljs-number">1</span>), d(<span class="hljs-literal">true</span> , i + <span class="hljs-number">1</span>) - prices[i]))<br>    <span class="hljs-keyword">return</span> d(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>&#125;;<br><br><span class="hljs-built_in">Object</span>：<br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> len = prices.length, h = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">let</span> t<br>    d = <span class="hljs-function">(<span class="hljs-params">s, i</span>) =&gt;</span> i === len  ? <span class="hljs-number">0</span> : <br>                  h[t = s ? i : len + i] !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? h[t] : h[t] = <br>                  (s ? <span class="hljs-built_in">Math</span>.max(d(s, i + <span class="hljs-number">1</span>), d(<span class="hljs-literal">false</span>, i + <span class="hljs-number">1</span>) + prices[i] - fee) :<br>                      <span class="hljs-built_in">Math</span>.max(d(s, i + <span class="hljs-number">1</span>), d(<span class="hljs-literal">true</span> , i + <span class="hljs-number">1</span>) - prices[i]))<br>    <span class="hljs-keyword">return</span> d(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>&#125;;<br><br><span class="hljs-built_in">Map</span>：<br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> len = prices.length, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span><br>    <span class="hljs-keyword">let</span> t, t1<br>    d = <span class="hljs-function">(<span class="hljs-params">s, i</span>) =&gt;</span> i === len  ? <span class="hljs-number">0</span> : <br>                  h.has(t = s ? i : len + i) ? h.get(t) : (h.set(t, t1 =  <br>                  (s ? <span class="hljs-built_in">Math</span>.max(d(s, i + <span class="hljs-number">1</span>), d(<span class="hljs-literal">false</span>, i + <span class="hljs-number">1</span>) + prices[i] - fee) :<br>                      <span class="hljs-built_in">Math</span>.max(d(s, i + <span class="hljs-number">1</span>), d(<span class="hljs-literal">true</span> , i + <span class="hljs-number">1</span>) - prices[i]))), t1)<br>    <span class="hljs-keyword">return</span> d(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>)<br>&#125;;<br><br><span class="hljs-number">0</span> <span class="hljs-literal">false</span>左分支 向下递归 → 向上回溯 得到<span class="hljs-number">0</span>后<br><span class="hljs-number">0</span> <span class="hljs-literal">false</span>右分支 向下递归 → 遇到缓存过的i和s，读缓存，不再向下递归。相应分支被剪枝<br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/di-gui-dong-tai-gui-hua-tan-xin-suan-fa-7wk97/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br><br></code></pre></td></tr></table></figure><h4 id="二-动态规划"><a href="#二-动态规划" class="headerlink" title="二 动态规划"></a>二 动态规划</h4><p>解题思路<br>最后一天，只有2种状态：手上无股票，手上有股票<br>对应最大利润dp = [无股票最大利润，有股票最大利润]<br>已知：dp[0] = 0 dp[1] = -第0日股票价格<br>从第1日开始，状态转移方程<br>dp[0] = max(观望：最大利润不变，卖出：有股票最大利润 + 当日股票价格 - 手续费)<br>dp[1] = max(持有：最大利润不变，买入：无股票最大利润 - 当日股票价格)  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> dp = [<span class="hljs-number">0</span>, -prices[<span class="hljs-number">0</span>]]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>, t; i &lt; prices.length; i++) &#123;<br>        t = dp[<span class="hljs-number">0</span>] <span class="hljs-comment">// 中间变量可省略，因为当天买入卖出不影响结果</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>] + prices[i] - fee)<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(dp[<span class="hljs-number">1</span>],     t - prices[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>] <span class="hljs-comment">// 最后一天，无股票 利润 &gt; 有股票时 利润</span><br>&#125;;<br><br>Reduce：<br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> prices.reduce(<span class="hljs-function">(<span class="hljs-params">p, v</span>) =&gt;</span> [<span class="hljs-built_in">Math</span>.max(p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>] + v - fee), <span class="hljs-built_in">Math</span>.max(p[<span class="hljs-number">1</span>], p[<span class="hljs-number">0</span>] - v)], [<span class="hljs-number">0</span>, -prices[<span class="hljs-number">0</span>]])[<span class="hljs-number">0</span>]<br>&#125;;<br><br>Reduce · 优化：归并数组请避免浅拷贝和新建<br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> prices.reduce(<span class="hljs-function">(<span class="hljs-params">p, v</span>) =&gt;</span> (p[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>] + v - fee), p[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(p[<span class="hljs-number">1</span>], p[<span class="hljs-number">0</span>] - v), p), [<span class="hljs-number">0</span>, -prices[<span class="hljs-number">0</span>]])[<span class="hljs-number">0</span>]<br>&#125;;<br><br>动态规划 · 状态机<br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> s0 = <span class="hljs-number">0</span>, s1 = -prices[<span class="hljs-number">0</span>], i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(++i &lt; prices.length) &#123;<br>        s0 = <span class="hljs-built_in">Math</span>.max(s0, s1 + prices[i] - fee)<br>        s1 = <span class="hljs-built_in">Math</span>.max(s1, s0 - prices[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> s0<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/di-gui-dong-tai-gui-hua-tan-xin-suan-fa-7wk97/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="三-贪心算法"><a href="#三-贪心算法" class="headerlink" title="三 贪心算法"></a>三 贪心算法</h4><p>解题思路<br>贪心策略：最低买，最高卖<br>遍历<br>无股票，找最低买入价格买入，不断更新min<br>有股票<br>今天价格 - 最低买入价格min - 手续费 &gt; 0，即有利润就卖<br>今天利润 = 昨天利润 + 今天价格 - 最低买入价格 - 手续费<br>新最低买入价格 = 今天价格 - 手续费，先假设今天卖出<br>第二天<br>今天价格 &gt; 昨天价格。改今天卖。手续费昨天扣过，不再扣<br>今天利润 = 昨天利润 + 今天价格 - 新最低买入价格 - 手续费<br>= 昨天利润 + 今天价格 - （昨天价格 - 手续费） - 手续费<br>= 昨天利润 + 今天价格 - 昨天价格<br>今天价格 &lt;= 昨天价格，先假设昨天卖出<br>回到无股票状态<br>今天价格 &lt; 新最低买入价格，准备买入，更新min<br>今天价格 &gt;= 新最低买入价格，观望<br>如果后面有比昨天卖出更高价格，昨天不卖了，改后面卖<br>后面利润计算方法和有股票时，第二天改今天卖时一样  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> min = prices[<span class="hljs-number">0</span>], r = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, t<br>    <span class="hljs-keyword">while</span>(++i &lt; prices.length) &#123;<br>        <span class="hljs-keyword">if</span> (prices[i] &lt; min) &#123;<br>            min = prices[i]<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((t = prices[i] - min - fee) &gt; <span class="hljs-number">0</span>) &#123;<br>            r += t<br>            min = prices[i] - fee<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>Reduce：<br><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices, fee, r = <span class="hljs-number">0</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> prices.reduce(<span class="hljs-function">(<span class="hljs-params">p, v, i</span>) =&gt;</span> i ? (v &lt; p ? v : v - p &gt; fee ? (r += v - p - fee, v - fee) : p) : p, prices[<span class="hljs-number">0</span>]), r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/di-gui-dong-tai-gui-hua-tan-xin-suan-fa-7wk97/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣290 单词规律</title>
    <link href="/2020/12/16/%E5%8A%9B%E6%89%A3290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/"/>
    <url>/2020/12/16/%E5%8A%9B%E6%89%A3290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p><p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p><p>示例1:</p><p>输入: pattern = “abba”, str = “dog cat cat dog”<br>输出: true  </p><p>示例 2:  </p><p>输入:pattern = “abba”, str = “dog cat cat fish”<br>输出: false</p><p>示例 3:</p><p>输入: pattern = “aaaa”, str = “dog cat cat dog”<br>输出: false</p><p>示例 4:</p><p>输入: pattern = “abba”, str = “dog dog dog dog”<br>输出: false<br>说明:<br>你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。    </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/word-pattern">https://leetcode-cn.com/problems/word-pattern</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>真的花了我好长时间debug，思路想到用双哈希进行对比，在采用对象的过程中无法正确比较对象的值（因为两个哈希的key是不一样的），然后又建立两个哈希用同样的0开始记录，然后又错用了对象长度导致比较错误（用Object.keys(obj))，做的过程中还感觉发烧了哈哈哈，然后下面照理贴一下小宇的题解</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">pattern</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a = &#123;&#125;, b = &#123;&#125;, c = &#123;&#125;, d = &#123;&#125;;<br>    <span class="hljs-keyword">const</span> p = pattern.split(<span class="hljs-string">&quot;&quot;</span>), q = s.split(<span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-keyword">if</span> (p.length !== q.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; p.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[p[i]]) &#123;<br>            a[p[i]].push(i);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            a[p[i]] = [i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; q.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (b[q[i]]) &#123;<br>            b[q[i]].push(i);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            b[q[i]] = [i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> u = <span class="hljs-number">0</span>, v = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> a) &#123;<br>        c[u++] = a[item];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> b) &#123;<br>        d[v++] = b[item];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">Object</span>.keys(c).length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (c[i].toString() !== d[i].toString()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="一-双哈希表-·-两次遍历"><a href="#一-双哈希表-·-两次遍历" class="headerlink" title="一 双哈希表 · 两次遍历"></a>一 双哈希表 · 两次遍历</h4><p>解题思路：<br>第一次遍历，检查pattern一个字母是否只对应str一个单词<br>第二次遍历，检查str一个单词是否只对应pattern一个字母</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Map</span>:<br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>), len = pattern.length<br>    <span class="hljs-keyword">if</span> (len !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">let</span> h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; len) &#123;<br>        <span class="hljs-keyword">const</span> p = pattern[i], s = a[i]<br>        <span class="hljs-keyword">if</span> (h.has(p)) &#123;<br>            <span class="hljs-keyword">if</span> (h.get(p) !== s) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            h.set(p, s)<br>        &#125;<br>    &#125;<br>    h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; len) &#123;<br>        <span class="hljs-keyword">const</span> p = pattern[i], s = a[i]<br>        <span class="hljs-keyword">if</span> (h.has(s)) &#123;<br>            <span class="hljs-keyword">if</span> (h.get(s) !== p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            h.set(s, p)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-built_in">Object</span>:<br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>), len = pattern.length<br>    <span class="hljs-keyword">if</span> (len !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">let</span> h = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; len) &#123;<br>        <span class="hljs-keyword">const</span> p = pattern[i], s = a[i]<br>        <span class="hljs-keyword">if</span> (h[p] !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (h[p] !== s) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            h[p] = s<br>        &#125;<br>    &#125;<br>    h = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; len) &#123;<br>        <span class="hljs-keyword">const</span> p = pattern[i], s = a[i]<br>        <span class="hljs-keyword">if</span> (h[s] !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (h[s] !== p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            h[s] = p<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/word-pattern/solution/suo-yin-ha-xi-biao-yuan-zu-ji-he-7xing-d-vw3o/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="双哈希表-·-一次遍历"><a href="#双哈希表-·-一次遍历" class="headerlink" title="双哈希表 · 一次遍历"></a>双哈希表 · 一次遍历</h4><p>解题思路<br>一次遍历，同时检查pattern-&gt;str和str-&gt;pattern是否对应。上解法代码合并即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Map</span>:<br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">if</span> (pattern.length !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">const</span> hp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, hs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>        <span class="hljs-keyword">let</span> p = pattern[i], s = a[i]<br>        <span class="hljs-keyword">if</span> (hp.has(p)) &#123;<br>            <span class="hljs-keyword">if</span> (hp.get(p) !== s) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hp.set(p, s)<br>        &#125;<br>        <span class="hljs-keyword">if</span> (hs.has(s)) &#123;<br>            <span class="hljs-keyword">if</span> (hs.get(s) !== p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hs.set(s, p)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-built_in">Object</span>:<br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">if</span> (pattern.length !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">const</span> hp = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), hs = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>        <span class="hljs-keyword">let</span> p = pattern[i], s = a[i]<br>        <span class="hljs-keyword">if</span> (hp[p] !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (hp[p] !== s) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hp[p] = s<br>        &#125;<br>        <span class="hljs-keyword">if</span> (hs[s] !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (hs[s] !== p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hs[s] = p<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/word-pattern/solution/suo-yin-ha-xi-biao-yuan-zu-ji-he-7xing-d-vw3o/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="三元组-·-集合"><a href="#三元组-·-集合" class="headerlink" title="三元组 · 集合"></a>三元组 · 集合</h4><p>解题思路<br>数组A和B，并列放置，每行是元组。Set去重。一一对应须满足<br>A与B的元组去重长度 = 数组A去重长度 = 数组B去重长度  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">if</span> (pattern.length !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">const</span> h = <span class="hljs-built_in">Array</span>(a.length)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>        h[i] = pattern[i] + <span class="hljs-string">&#x27;,&#x27;</span> + a[i] <span class="hljs-comment">// 无原生元组，用逗号分隔表示，唯一即可</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> len = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(h).size<br>    <span class="hljs-keyword">return</span> len === <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(pattern).size &amp;&amp; len === <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(a).size<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/word-pattern/solution/suo-yin-ha-xi-biao-yuan-zu-ji-he-7xing-d-vw3o/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="四-索引-·-累加"><a href="#四-索引-·-累加" class="headerlink" title="四 索引 · 累加"></a>四 索引 · 累加</h4><p>解题思路<br>一一对应两个元素，在各自数组中，首次出现索引相同<br>abba -&gt; 0110 = dog cat cat dog -&gt; 0110  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript">indexOf:<br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>), len = pattern.length<br>    <span class="hljs-keyword">if</span> (len !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">let</span> sums = <span class="hljs-string">&#x27;&#x27;</span>, sump = <span class="hljs-string">&#x27;&#x27;</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; len) &#123;<br>        sums += a.indexOf(a[i])<br>        sump += pattern.indexOf(pattern[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> sums === sump<br>&#125;;<br><span class="hljs-built_in">Map</span>:<br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>), len = pattern.length<br>    <span class="hljs-keyword">if</span> (len !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">let</span> sums = <span class="hljs-string">&#x27;&#x27;</span>, sump = <span class="hljs-string">&#x27;&#x27;</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">const</span> hs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, hp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span><br>    <span class="hljs-keyword">while</span>(++i &lt; len) &#123;<br>        <span class="hljs-keyword">const</span> s = a[i], p = pattern[i]<br>        sums += hs.has(s) ? hs.get(s) : (hs.set(s, i), i)<br>        sump += hp.has(p) ? hp.get(p) : (hp.set(p, i), i)<br>    &#125;<br>    <span class="hljs-keyword">return</span> sums === sump<br>&#125;;<br><span class="hljs-built_in">Object</span>:<br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>), len = pattern.length<br>    <span class="hljs-keyword">if</span> (len !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">let</span> sums = <span class="hljs-string">&#x27;&#x27;</span>, sump = <span class="hljs-string">&#x27;&#x27;</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">const</span> hs = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), hp = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">while</span>(++i &lt; len) &#123;<br>        <span class="hljs-keyword">const</span> s = a[i], p = pattern[i]<br>        sums += hs[s] !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? hs[s] : hs[s] = i<br>        sump += hp[p] !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? hp[p] : hp[p] = i<br>    &#125;<br>    <span class="hljs-keyword">return</span> sums === sump<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/word-pattern/solution/suo-yin-ha-xi-biao-yuan-zu-ji-he-7xing-d-vw3o/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="五-索引-·-逐位比较"><a href="#五-索引-·-逐位比较" class="headerlink" title="五 索引 · 逐位比较"></a>五 索引 · 逐位比较</h4><p>解题思路<br>逐位比较首次出现索引：indexOf获取 或 哈希表保存<br>charCodeAt(i)将pattern字母转Unicode，不与str键名冲突，可用单哈希表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript">indexOf:<br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">if</span> (pattern.length !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pattern.length; i++)<br>        <span class="hljs-keyword">if</span> (pattern.indexOf(pattern[i]) !== a.indexOf(a[i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-built_in">Map</span>:<br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">if</span> (pattern.length !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">const</span> h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pattern.length; i++)<br>        <span class="hljs-keyword">if</span> (v(h, pattern.charCodeAt(i), i) !== v(h, a[i], i)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-keyword">var</span> v = <span class="hljs-function">(<span class="hljs-params">h, k, v</span>) =&gt;</span> h.has(k) ? h.get(k) : (h.set(k, v), v)<br><span class="hljs-attr">Object</span>:<br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">if</span> (pattern.length !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">const</span> h = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pattern.length; i++)<br>        <span class="hljs-keyword">if</span> (v(h, pattern.charCodeAt(i), i) !== v(h, a[i], i)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-keyword">var</span> v = <span class="hljs-function">(<span class="hljs-params">h, k, v</span>) =&gt;</span> h[k] !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> ? h[k] : h[k] = v<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/word-pattern/solution/suo-yin-ha-xi-biao-yuan-zu-ji-he-7xing-d-vw3o/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="单哈希表"><a href="#单哈希表" class="headerlink" title="单哈希表"></a>单哈希表</h4><p>解题思路<br>来自利用哈希表简单解决<br>遍历pattern，当前字符p，当前单词s，哈希表h<br>h中无p<br>有s，返回false<br>无s，加s<br>h中有p<br>p对应值与s不对应，返回false  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Map</span>:<br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">if</span> (pattern.length !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">const</span> h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>        <span class="hljs-keyword">let</span> p = pattern.charCodeAt(i), s = a[i]<br>        <span class="hljs-keyword">if</span> (!h.has(p)) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.from(h.values()).includes(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            h.set(p, s)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (h.get(p) !== s) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-built_in">Object</span>:<br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">if</span> (pattern.length !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">const</span> h = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>        <span class="hljs-keyword">let</span> p = pattern.charCodeAt(i), s = a[i]<br>        <span class="hljs-keyword">if</span> (h[p] === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.values(h).includes(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            h[p] = s<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (h[p] !== s) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><span class="hljs-built_in">Array</span>:<br><span class="hljs-keyword">var</span> wordPattern = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pattern, s</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> a = s.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>    <span class="hljs-keyword">if</span> (pattern.length !== a.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">const</span> h = <span class="hljs-built_in">Array</span>(<span class="hljs-number">26</span>)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>        <span class="hljs-keyword">let</span> p = pattern.charCodeAt(i) - <span class="hljs-number">97</span>, s = a[i]<br>        <span class="hljs-keyword">if</span> (h[p] === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (h.includes(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            h[p] = s<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (h[p] !== s) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/word-pattern/solution/suo-yin-ha-xi-biao-yuan-zu-ji-he-7xing-d-vw3o/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣62 不同路径</title>
    <link href="/2020/12/15/%E5%8A%9B%E6%89%A362-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <url>/2020/12/15/%E5%8A%9B%E6%89%A362-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例 1：</p><p>输入：m = 3, n = 7<br>输出：28<br>示例 2：</p><p>输入：m = 3, n = 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右<br>示例 3：</li></ol><p>输入：m = 7, n = 3<br>输出：28<br>示例 4：</p><p>输入：m = 3, n = 3<br>输出：6 </p><p>提示：</p><p>1 &lt;= m, n &lt;= 100<br>题目数据保证答案小于等于 2 * 109</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths">https://leetcode-cn.com/problems/unique-paths</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>今天课设源码做完了多做了一题，思路直接想到dp很快就能做出来，主要是JS的二元数组初始化问题，照例学习小宇的代码和思路，JS算法冲冲冲</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="本人题解"><a href="#本人题解" class="headerlink" title="本人题解"></a>本人题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">m</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k=<span class="hljs-number">0</span>;k&lt;m;k++)&#123; <br>     dp[k]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="他人题解"><a href="#他人题解" class="headerlink" title="他人题解"></a>他人题解</h3><h4 id="递归-·-深度优先搜索"><a href="#递归-·-深度优先搜索" class="headerlink" title="递归 · 深度优先搜索"></a>递归 · 深度优先搜索</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">无记忆化（超时）：<br>从[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]到[m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>]，每次i + <span class="hljs-number">1</span>或j + <span class="hljs-number">1</span>。直到越界或到达，到达路线数+<span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> i === m - <span class="hljs-number">1</span> &amp;&amp; j === n - <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : i === m || j === n ? <span class="hljs-number">0</span> : uniquePaths(m, n, i + <span class="hljs-number">1</span>, j) + uniquePaths(m, n, i, j + <span class="hljs-number">1</span>)<br>&#125;;<br><br>记忆化：<br><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, t, t1</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> i === m - <span class="hljs-number">1</span> &amp;&amp; j === n - <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : i === m || j === n ? <span class="hljs-number">0</span> : h.has(t = i * <span class="hljs-number">100</span> + j) ? h.get(t) : (h.set(t, (t1 = uniquePaths(m, n, i + <span class="hljs-number">1</span>, j, h) + uniquePaths(m, n, i, j + <span class="hljs-number">1</span>, h))), t1)<br>&#125;;<br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/unique-paths/solution/di-gui-dong-tai-gui-hua-jiang-wei-zu-he-xlwrx/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">dp[i][j]到达点[i, j]路径数，dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br>已知到i === <span class="hljs-number">0</span>首行，j === <span class="hljs-number">0</span>首列上的点路径数都为<span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n, dp = <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(&#123;length: m&#125;, _ =&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(n))</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br>&#125;;<br>三元判断：<br><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n, dp = <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(&#123;length: m&#125;, _ =&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(n))</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            dp[i][j] = i === <span class="hljs-number">0</span> || j === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]<br>&#125;;<br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/unique-paths/solution/di-gui-dong-tai-gui-hua-jiang-wei-zu-he-xlwrx/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="动态规划-·-降维"><a href="#动态规划-·-降维" class="headerlink" title="动态规划 · 降维"></a>动态规划 · 降维</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript">解题思路<br>遍历行，dp[j]到列j路径数。扫描列：本行dp[j] = 上行dp[j] ↓ + 左列dp[j - <span class="hljs-number">1</span>]→<br>遍历列，dp[i]到行i路径数。扫描行：本列dp[i] = 左列dp[i]→ + 上行dp[i - <span class="hljs-number">1</span>]↓<br>代码<br>遍历行，扫描列，直到第m - <span class="hljs-number">1</span>行的第n - <span class="hljs-number">1</span>列，即点[m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n, dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(n).fill(<span class="hljs-number">1</span>)</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) dp[j] = dp[j] + dp[j-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>] <span class="hljs-comment">// 即 dp[dp.length - 1]</span><br>&#125;;<br><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n, dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(n).fill(<span class="hljs-number">1</span>), i = <span class="hljs-number">0</span></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span>(j = <span class="hljs-number">0</span>, ++i &lt; m) <span class="hljs-keyword">while</span>(++j &lt; n) dp[j] += dp[j - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>]<br>&#125;;<br>遍历列，扫描行，直到第n - <span class="hljs-number">1</span>列的第m - <span class="hljs-number">1</span>行，即点[m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>]<br><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n, dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(m).fill(<span class="hljs-number">1</span>)</span>) </span>&#123;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) dp[i] = dp[i] + dp[i-<span class="hljs-number">1</span>]<br>   <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>] <span class="hljs-comment">// 即 dp[dp.length - 1]</span><br>&#125;;<br><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n, dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(m).fill(<span class="hljs-number">1</span>), j = <span class="hljs-number">0</span></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span>(i = <span class="hljs-number">0</span>, ++j &lt; n) <span class="hljs-keyword">while</span>(++i &lt; m) dp[i] += dp[i - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>]<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/unique-paths/solution/di-gui-dong-tai-gui-hua-jiang-wei-zu-he-xlwrx/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">解题思路<br>从[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]走到[m, n]，只能向右或向下，总步数 m - <span class="hljs-number">1</span> + n - <span class="hljs-number">1</span> = m + n - <span class="hljs-number">2</span>步<br>向右走m - <span class="hljs-number">1</span>步时，一定向下走n - <span class="hljs-number">1</span>步。从总步数选m - <span class="hljs-number">1</span>或n - <span class="hljs-number">1</span>种组合都行<br>以选m - <span class="hljs-number">1</span>为例：<br>C(m + n - <span class="hljs-number">2</span>, m - <span class="hljs-number">1</span>) = (m + n - <span class="hljs-number">2</span>)! / (m - <span class="hljs-number">1</span>)! * (n - <span class="hljs-number">1</span>)! =<br>(m + n - <span class="hljs-number">2</span>) * (m + n - <span class="hljs-number">1</span>) ... m * （m - <span class="hljs-number">1</span> * m - <span class="hljs-number">2</span> ... <span class="hljs-number">1</span>）<br>—————————————————————— =<br>　　　　　(m - <span class="hljs-number">1</span> * m - <span class="hljs-number">2</span> ... <span class="hljs-number">1</span>) * (n - <span class="hljs-number">1</span>)!<br>　　　　　(m + n - <span class="hljs-number">2</span>) * (m + n - <span class="hljs-number">1</span>) ... m<br>—————————————————————— =<br>　　　　　　　　　　(n - <span class="hljs-number">1</span>)!<br>　　ｍ起，每次加<span class="hljs-number">1</span> 到 m + n - <span class="hljs-number">2</span>，累乘n - <span class="hljs-number">1</span>次<br>—————————————————————— =<br>　　　<span class="hljs-number">1</span>起，每次加<span class="hljs-number">1</span> 到 n - <span class="hljs-number">1</span>， 累乘n - <span class="hljs-number">1</span>次<br>代码<br>选m - <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n, r = <span class="hljs-number">1</span>, i = m, j = <span class="hljs-number">1</span></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span>(j &lt; n) r = r * i++ / j++ | <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br>选n - <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> uniquePaths = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, n, r = <span class="hljs-number">1</span>, i = n, j = <span class="hljs-number">1</span></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span>(j &lt; m) r = r * i++ / j++ | <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/unique-paths/solution/di-gui-dong-tai-gui-hua-jiang-wei-zu-he-xlwrx/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>动态规划</tag>
      
      <tag>记忆化</tag>
      
      <tag>组合</tag>
      
      <tag>降维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣738 单调递增的数字</title>
    <link href="/2020/12/15/%E5%8A%9B%E6%89%A3738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/12/15/%E5%8A%9B%E6%89%A3738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p><p>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。）</p><p>示例 1:</p><p>输入: N = 10<br>输出: 9<br>示例 2:  </p><p>输入: N = 1234<br>输出: 1234<br>示例 3:  </p><p>输入: N = 332<br>输出: 299<br>说明: N 是在 [0, 10^9] 范围内的一个整数。  </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/monotone-increasing-digits">https://leetcode-cn.com/problems/monotone-increasing-digits</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>今天这题一开始想的很复杂，后面以小数据推起，两位两位比较贪心就好了，能取就取不能取前一位减一后一位取9即可，顺便复习一下字符串、数组、数字的相互转化，照理挂一下小宇的解法（包括他借鉴的累加法，还有后面更新的低位到高位 · 数组）</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">N</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> monotoneIncreasingDigits = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> num =N.toString();<br>    <span class="hljs-keyword">let</span> a= <span class="hljs-built_in">Array</span>.from(num);<br>    <span class="hljs-keyword">let</span> flag=a.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=a.length-<span class="hljs-number">1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;a[i-<span class="hljs-number">1</span>])&#123;<br>            a[i-<span class="hljs-number">1</span>]--;<br>            flag=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=a.length-<span class="hljs-number">1</span>;i&gt;=flag;i--)&#123;<br>        a[i]=<span class="hljs-string">&#x27;9&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(a.join(<span class="hljs-string">&quot;&quot;</span>));<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="枚举（会超时）"><a href="#枚举（会超时）" class="headerlink" title="枚举（会超时）"></a>枚举（会超时）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> monotoneIncreasingDigits = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = N + <span class="hljs-number">1</span>; n--;) &#123;<br>        <span class="hljs-keyword">let</span> find = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = length(N); i-- &gt; <span class="hljs-number">1</span>;) &#123;<br>            <span class="hljs-keyword">if</span> (digit(n, i - <span class="hljs-number">1</span>) &lt; digit(n, i)) &#123;<br>                find = <span class="hljs-literal">false</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (find) <span class="hljs-keyword">return</span> n<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">var</span> length = <span class="hljs-function"><span class="hljs-params">N</span> =&gt;</span> <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Math</span>.log(N + <span class="hljs-number">1</span>) / <span class="hljs-built_in">Math</span>.LN10)<br><span class="hljs-keyword">var</span> digit = <span class="hljs-function">(<span class="hljs-params">N, i</span>) =&gt;</span> (N / <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, i) | <span class="hljs-number">0</span>) % <span class="hljs-number">10</span><br><br>获取数字长度：<span class="hljs-built_in">Math</span> &gt; 模板字符串.length &gt; toString().length &gt; <span class="hljs-built_in">String</span>().length<br>获取数字指定位：从右向左，从<span class="hljs-number">0</span>到最高位。数字整除<span class="hljs-number">10</span>的位数次方模<span class="hljs-number">10</span>取余即可<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/monotone-increasing-digits/solution/mei-ju-shuang-zhi-zhen-bian-li-shu-xue-y-5i2o/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">贪心策略<br>枚举是最低位递减，减到<span class="hljs-number">0</span>，向更高位借<span class="hljs-number">1</span>，再重复的过程<br>如<span class="hljs-number">342</span>不是，<span class="hljs-number">341</span> <span class="hljs-number">340</span>一定不是<br>更高位借<span class="hljs-number">1</span>，<span class="hljs-number">339</span>即解<br>如<span class="hljs-number">332</span>不是，<span class="hljs-number">331</span> <span class="hljs-number">330</span>一定不是<br>更高位借<span class="hljs-number">1</span>，<span class="hljs-number">329</span>不是，再向更高位借<span class="hljs-number">1</span>，<span class="hljs-number">299</span>即解<br>即前数等于前前数，一定要再向更高位借<span class="hljs-number">1</span><br>贪心策略：递减位置起，向更高位，找借<span class="hljs-number">1</span>后能使序列递增的最高位<br>即递减位置起，前数第一次等于前前数的位置，借<span class="hljs-number">1</span>即解<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/monotone-increasing-digits/solution/mei-ju-shuang-zhi-zhen-bian-li-shu-xue-y-5i2o/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript">解题思路<br>从高位到低位，以转字符串遍历为例，指针i顺序遍历递增<br>当前数 &lt; 前数<br>前数 === 前前数，指针j从前数i - <span class="hljs-number">1</span>继续向左<br>字符串j - <span class="hljs-number">1</span>，数字j + <span class="hljs-number">1</span>，直到不等<br>结果 = [<span class="hljs-number">0</span>, j)拷贝 + (j位 - <span class="hljs-number">1</span>) + (j, s.length)填<span class="hljs-number">9</span>。|<span class="hljs-number">0</span>转回数字<br>数字遍历解法，指针i倒序遍历递减，即位数。无需s.length - <span class="hljs-number">1</span> -j转换<br><br>转字符串遍历 + 字符串拼接:<br><span class="hljs-keyword">var</span> monotoneIncreasingDigits = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> s = N.toString(), j = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; s.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] &lt; s[i - <span class="hljs-number">1</span>]) &#123;<br>            j = i - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; s[j] === s[j - <span class="hljs-number">1</span>]) j--<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j &lt; <span class="hljs-number">0</span> ? N : s.slice(<span class="hljs-number">0</span>, j) + s[j] - <span class="hljs-number">1</span> + <span class="hljs-string">&#x27;9&#x27;</span>.repeat(s.length - <span class="hljs-number">1</span> - j) | <span class="hljs-number">0</span><br>&#125;;<br>数字遍历 + 字符串拼接:<br><span class="hljs-keyword">var</span> monotoneIncreasingDigits = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> len = length(N), j = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = len; i-- &gt; <span class="hljs-number">1</span>;) &#123;<br>        <span class="hljs-keyword">if</span> (digit(N, i - <span class="hljs-number">1</span>) &lt; digit(N, i)) &#123;<br>            j = i<br>            <span class="hljs-keyword">while</span>(j &lt; len &amp;&amp; digit(N, j + <span class="hljs-number">1</span>) === digit(N, j)) j++<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j &lt; <span class="hljs-number">0</span> ? N : (N / <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, j + <span class="hljs-number">1</span>) | <span class="hljs-number">0</span>) + <span class="hljs-string">&#x27;&#x27;</span> + digit(N, j) - <span class="hljs-number">1</span> + <span class="hljs-string">&#x27;9&#x27;</span>.repeat(j) | <span class="hljs-number">0</span><br>&#125;;<br><span class="hljs-keyword">var</span> length = <span class="hljs-function"><span class="hljs-params">N</span> =&gt;</span> <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Math</span>.log(N + <span class="hljs-number">1</span>) / <span class="hljs-built_in">Math</span>.LN10)<br><span class="hljs-keyword">var</span> digit = <span class="hljs-function">(<span class="hljs-params">N, i</span>) =&gt;</span> (N / <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, i) | <span class="hljs-number">0</span>) % <span class="hljs-number">10</span><br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/monotone-increasing-digits/solution/mei-ju-shuang-zhi-zhen-bian-li-shu-xue-y-5i2o/</span><br>来源：力扣（LeetCode）<br></code></pre></td></tr></table></figure><h4 id="记忆位置"><a href="#记忆位置" class="headerlink" title="记忆位置"></a>记忆位置</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs javascript">解题思路<br>双指针解法，指针j向左，返回的位置之前遍历过。可在遍历时，记忆j要返回的位置<br>当前数 = 前数，记忆重复数开始位置。如<span class="hljs-number">3332</span>，记忆<span class="hljs-number">3</span>第一次出现即<span class="hljs-number">0</span><br>多组重复数，记忆最后一组重复数开始位置。如<span class="hljs-number">33551</span>，记忆<span class="hljs-number">5</span>第一次出现即<span class="hljs-number">2</span><br>当前数 &lt; 前数<br>有重复数，返回记忆位置<br>没有，返回上个位置<br>代码<br><br>转字符串遍历 + 字符串拼接:<br><span class="hljs-keyword">var</span> monotoneIncreasingDigits = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> s = N.toString(), i = <span class="hljs-number">0</span>, j = -<span class="hljs-number">1</span>, repeatStart = -<span class="hljs-number">1</span>, repeatN = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(++i &lt; s.length) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] === s[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">if</span> (repeatN !== s[i]) &#123;<br>                repeatStart = i - <span class="hljs-number">1</span><br>                repeatN = s[i]<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] &lt; s[i - <span class="hljs-number">1</span>]) &#123;<br>            j = s[i - <span class="hljs-number">2</span>] === s[i - <span class="hljs-number">1</span>] ? repeatStart : i - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j &lt; <span class="hljs-number">0</span> ? N : s.slice(<span class="hljs-number">0</span>, j) + s[j] - <span class="hljs-number">1</span> + <span class="hljs-string">&#x27;9&#x27;</span>.repeat(s.length - <span class="hljs-number">1</span> - j) | <span class="hljs-number">0</span><br>&#125;;<br><br>数字遍历 + 字符串拼接:<br><span class="hljs-keyword">var</span> monotoneIncreasingDigits = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> len = length(N), j = -<span class="hljs-number">1</span>, repeatStart = -<span class="hljs-number">1</span>, repeatN = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = len; i-- &gt; <span class="hljs-number">1</span>;) &#123;<br>        <span class="hljs-keyword">var</span> cur = digit(N, i), next = digit(N, i - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> (next === cur &amp;&amp; repeatN !== cur) &#123;<br>            repeatStart = i<br>            repeatN = cur<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next &lt; cur) &#123;<br>            j = digit(N, i + <span class="hljs-number">1</span>) === cur ? repeatStart : i<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j &lt; <span class="hljs-number">0</span> ? N : (N / <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, j + <span class="hljs-number">1</span>) | <span class="hljs-number">0</span>) + <span class="hljs-string">&#x27;&#x27;</span> + digit(N, j) - <span class="hljs-number">1</span> + <span class="hljs-string">&#x27;9&#x27;</span>.repeat(j) | <span class="hljs-number">0</span><br>&#125;;<br><span class="hljs-keyword">var</span> length = <span class="hljs-function"><span class="hljs-params">N</span> =&gt;</span> <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Math</span>.log(N + <span class="hljs-number">1</span>) / <span class="hljs-built_in">Math</span>.LN10)<br><span class="hljs-keyword">var</span> digit = <span class="hljs-function">(<span class="hljs-params">N, i</span>) =&gt;</span> (N / <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, i) | <span class="hljs-number">0</span>) % <span class="hljs-number">10</span><br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/monotone-increasing-digits/solution/mei-ju-shuang-zhi-zhen-bian-li-shu-xue-y-5i2o/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="数学运算-·-累加1"><a href="#数学运算-·-累加1" class="headerlink" title="数学运算 · 累加1:"></a>数学运算 · 累加1:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript">任何单调递增序列分解成 = <span class="hljs-number">1</span>累加的形式（题目<span class="hljs-number">10</span>^<span class="hljs-number">9</span>，故最多九次）<br>如<span class="hljs-number">156</span> = <span class="hljs-number">111</span> + <span class="hljs-number">11</span> + <span class="hljs-number">11</span> + <span class="hljs-number">11</span> + <span class="hljs-number">11</span> + <span class="hljs-number">1</span><br>初始化<span class="hljs-number">1111</span>（比<span class="hljs-number">156</span>大的，最接近的）<br><span class="hljs-number">1111</span> &gt; <span class="hljs-number">156</span>：<span class="hljs-number">1111</span> / <span class="hljs-number">10</span>取整<span class="hljs-number">111</span><br><span class="hljs-number">111</span> + <span class="hljs-number">111</span> &gt; <span class="hljs-number">156</span>：<span class="hljs-number">111</span> / <span class="hljs-number">10</span>取整<span class="hljs-number">11</span><br><span class="hljs-number">111</span> + <span class="hljs-number">11</span> &lt; <span class="hljs-number">156</span>：继续加<br><span class="hljs-number">122</span> + <span class="hljs-number">11</span> &lt; <span class="hljs-number">156</span>：继续加<br><span class="hljs-number">133</span> + <span class="hljs-number">11</span> &lt; <span class="hljs-number">156</span>：继续加<br><span class="hljs-number">144</span> + <span class="hljs-number">11</span> &lt; <span class="hljs-number">155</span>：继续加<br><span class="hljs-number">155</span> + <span class="hljs-number">11</span> &gt; <span class="hljs-number">156</span>：<span class="hljs-number">11</span> / <span class="hljs-number">10</span>取整<span class="hljs-number">1</span><br><span class="hljs-number">155</span> + <span class="hljs-number">1</span> = <span class="hljs-number">156</span>：返回<span class="hljs-number">156</span><br>如<span class="hljs-number">154</span>非单调递增，找最接近<br>初始化<span class="hljs-number">1111</span><br><span class="hljs-number">1111</span> &gt; <span class="hljs-number">154</span>：<span class="hljs-number">1111</span> / <span class="hljs-number">10</span>取整<span class="hljs-number">111</span><br><span class="hljs-number">111</span> + <span class="hljs-number">111</span> &gt; <span class="hljs-number">154</span>：<span class="hljs-number">111</span> / <span class="hljs-number">10</span>取整<span class="hljs-number">11</span><br><span class="hljs-number">111</span> + <span class="hljs-number">11</span> &lt; <span class="hljs-number">154</span>：继续加<br><span class="hljs-number">122</span> + <span class="hljs-number">11</span> &lt; <span class="hljs-number">154</span>：继续加<br><span class="hljs-number">133</span> + <span class="hljs-number">11</span> &lt; <span class="hljs-number">154</span>：继续加<br><span class="hljs-number">144</span> + <span class="hljs-number">11</span> &lt; <span class="hljs-number">154</span>：继续加<br><span class="hljs-number">144</span> + <span class="hljs-number">11</span> &gt; <span class="hljs-number">154</span>：<span class="hljs-number">11</span> / <span class="hljs-number">10</span>取整<span class="hljs-number">1</span><br><span class="hljs-number">144</span> + <span class="hljs-number">1</span> &lt; <span class="hljs-number">156</span>：继续加<br><span class="hljs-number">145</span> + <span class="hljs-number">1</span> &lt; <span class="hljs-number">156</span>：继续加<br><span class="hljs-number">146</span> + <span class="hljs-number">1</span> &lt; <span class="hljs-number">156</span>：继续加<br><span class="hljs-number">147</span> + <span class="hljs-number">1</span> &lt; <span class="hljs-number">156</span>：继续加<br><span class="hljs-number">148</span> + <span class="hljs-number">1</span> &lt; <span class="hljs-number">156</span>：加了<span class="hljs-number">9</span>次，停，返回<span class="hljs-number">149</span><br><br><span class="hljs-keyword">var</span> monotoneIncreasingDigits = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> r = <span class="hljs-number">0</span>, s = <span class="hljs-number">111111111</span>, i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (++i &lt; <span class="hljs-number">9</span>) &#123;<br>        <span class="hljs-keyword">while</span> (r + s &gt; N) s = s / <span class="hljs-number">10</span> | <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> ((r += s) === N) <span class="hljs-keyword">return</span> r<br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/monotone-increasing-digits/solution/mei-ju-shuang-zhi-zhen-bian-li-shu-xue-y-5i2o/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h4 id="低位到高位-·-数学运算-·-最快"><a href="#低位到高位-·-数学运算-·-最快" class="headerlink" title="低位到高位 · 数学运算 · 最快"></a>低位到高位 · 数学运算 · 最快</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> monotoneIncreasingDigits = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">N</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> low, high, i = <span class="hljs-number">1</span>, r = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (N) &#123;<br>        low = N % <span class="hljs-number">10</span><br>        N = N / <span class="hljs-number">10</span> | <span class="hljs-number">0</span><br>        high = N % <span class="hljs-number">10</span><br>        <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>            r = i * <span class="hljs-number">10</span> - <span class="hljs-number">1</span><br>            N--<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r += low * i<br>        &#125;<br>        i *= <span class="hljs-number">10</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> r<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/monotone-increasing-digits/solution/mei-ju-shuang-zhi-zhen-bian-li-shu-xue-y-5i2o/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>贪心算法</tag>
      
      <tag>字符串</tag>
      
      <tag>记忆化</tag>
      
      <tag>数学思维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣49 字母易位词分组</title>
    <link href="/2020/12/14/%E5%8A%9B%E6%89%A349-%E5%AD%97%E6%AF%8D%E6%98%93%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <url>/2020/12/14/%E5%8A%9B%E6%89%A349-%E5%AD%97%E6%AF%8D%E6%98%93%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p>示例:</p><p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>说明：</p><p>所有输入均为小写字母。<br>不考虑答案输出的顺序。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/group-anagrams">https://leetcode-cn.com/problems/group-anagrams</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。     </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始想到用哈希思路用数来代替字母然后求积，后面对质数操作也不熟悉，下面贴了哈希做法，本题我还是用了排序，不过没有用数组或者map进行处理导致超时，而后进行更改，同时同样贴上小宇大佬的代码和解析，思路清晰多样且代码真的做到尽可能简洁</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">strs</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[][]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> obj=&#123;&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;strs.length;i++)&#123;<br>        <span class="hljs-keyword">let</span> a=strs[i].split(<span class="hljs-string">&quot;&quot;</span>).sort().toString();<br>        <span class="hljs-keyword">if</span>(obj[a])&#123;<br>            obj[a].push(strs[i])<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            obj[a]=[strs[i]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(obj);<br>&#125;;<br></code></pre></td></tr></table></figure><p>质数<br>解题思路<br>算术基本定理<br>任何一个大于1的自然数N，如果N不为质数，那么N可以唯一分解成有限个质数的乘积<br>[a, z]Unicode编码 - 97=[0, 25] 对应26个质数。每字母代表质数的乘积表示字符串<br>乘法交换律忽略字母顺序。算术基本定理保证不同质数 或 相同质数不同个数，乘积唯一<br>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Map</span>:<br><span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, prime = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span>, <span class="hljs-number">31</span>, <span class="hljs-number">37</span>, <span class="hljs-number">41</span>, <span class="hljs-number">43</span>, <span class="hljs-number">47</span>, <span class="hljs-number">53</span>, <span class="hljs-number">59</span>, <span class="hljs-number">61</span>, <span class="hljs-number">67</span>, <span class="hljs-number">71</span>, <span class="hljs-number">73</span>, <span class="hljs-number">79</span>, <span class="hljs-number">83</span>, <span class="hljs-number">89</span>, <span class="hljs-number">97</span>, <span class="hljs-number">101</span>]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>, sum = <span class="hljs-number">1</span>; j &lt; strs[i].length; j++)<br>            sum *= prime[strs[i].charCodeAt(j) - <span class="hljs-number">97</span>]<br>        h.has(sum) ? h.get(sum).push(strs[i]) : h.set(sum, [strs[i]])<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(h.values())<br>&#125;;    <br><br><span class="hljs-built_in">Object</span>:<br><span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> h = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), prime = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span>, <span class="hljs-number">29</span>, <span class="hljs-number">31</span>, <span class="hljs-number">37</span>, <span class="hljs-number">41</span>, <span class="hljs-number">43</span>, <span class="hljs-number">47</span>, <span class="hljs-number">53</span>, <span class="hljs-number">59</span>, <span class="hljs-number">61</span>, <span class="hljs-number">67</span>, <span class="hljs-number">71</span>, <span class="hljs-number">73</span>, <span class="hljs-number">79</span>, <span class="hljs-number">83</span>, <span class="hljs-number">89</span>, <span class="hljs-number">97</span>, <span class="hljs-number">101</span>]<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>, sum = <span class="hljs-number">1</span>; j &lt; strs[i].length; j++) <br>            sum *= prime[strs[i][j].charCodeAt() - <span class="hljs-number">97</span>]<br>        h[sum] ? h[sum].push(strs[i]) : h[sum] = [strs[i]]<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(h)<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/group-anagrams/solution/zhi-shu-pai-xu-shu-zu-6xing-dai-ma-chao-9kdni/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>Sort<br>解题思路<br>Sort忽略参数，按元素Unicode位点排序，即Unicode编码升序排列<br>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Map</span>:<br><span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>, k<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) <br>        h.has(k = strs[i].split(<span class="hljs-string">&#x27;&#x27;</span>).sort().join(<span class="hljs-string">&#x27;&#x27;</span>)) ? h.get(k).push(strs[i]) : h.set(k, [strs[i]])<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(h.values())<br>&#125;;<br><br><span class="hljs-built_in">Object</span>:<br><span class="hljs-keyword">var</span> groupAnagrams = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> h = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>), k<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) <br>        h[k = strs[i].split(<span class="hljs-string">&#x27;&#x27;</span>).sort().join(<span class="hljs-string">&#x27;&#x27;</span>)] ? h[k].push(strs[i]) : h[k] = [strs[i]]<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.values(h)<br>&#125;;<br><br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/group-anagrams/solution/zhi-shu-pai-xu-shu-zu-6xing-dai-ma-chao-9kdni/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>廖雪峰JS笔记</title>
    <link href="/2020/12/13/%E5%BB%96%E9%9B%AA%E5%B3%B0JS%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/12/13/%E5%BB%96%E9%9B%AA%E5%B3%B0JS%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="arguments参数"><a href="#arguments参数" class="headerlink" title="arguments参数"></a>arguments参数</h3><p>利用arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-keyword">function</span> <span class="hljs-built_in">abs</span>() &#123;<br>    <span class="hljs-keyword">if</span> (arguments.length === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span> = arguments[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-symbol">x</span> &gt;= <span class="hljs-number">0</span> ? <span class="hljs-symbol">x</span> : -<span class="hljs-symbol">x</span>;<br>&#125;<br><br><span class="hljs-built_in">abs</span>(); <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">abs</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">abs</span>(<span class="hljs-number">-9</span>); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><h3 id="rest参数和…（逆向rest）"><a href="#rest参数和…（逆向rest）" class="headerlink" title="rest参数和…（逆向rest）"></a>rest参数和…（逆向rest）</h3><p>为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？</p><p>ES6标准引入了rest参数，上面的函数可以改写为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(a, b, <span class="hljs-rest_arg">...rest</span>)</span> </span>&#123;<br>    console.log(<span class="hljs-string">&#x27;a = &#x27;</span> + a);<br>    console.log(<span class="hljs-string">&#x27;b = &#x27;</span> + b);<br>    console.log(rest);<br>&#125;<br><br>foo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">// 结果:</span><br><span class="hljs-comment">// a = 1</span><br><span class="hljs-comment">// b = 2</span><br><span class="hljs-comment">// Array [ 3, 4, 5 ]</span><br><br>foo(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 结果:</span><br><span class="hljs-comment">// a = 1</span><br><span class="hljs-comment">// b = undefined</span><br><span class="hljs-comment">// Array []</span><br></code></pre></td></tr></table></figure><h3 id="apply和call"><a href="#apply和call" class="headerlink" title="apply和call"></a>apply和call</h3><p>虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！</p><p>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p><p>另一个与apply()类似的方法是call()，唯一区别是：</p><p>apply()把参数打包成Array再传入；</p><p>call()把参数按顺序传入。</p><p>比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm">Math.<span class="hljs-keyword">max</span>.apply(<span class="hljs-keyword">null</span><span class="hljs-punctuation">,</span> [<span class="hljs-number">3</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span>])<span class="hljs-comment">; // 5</span><br>Math.<span class="hljs-keyword">max</span>.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">null</span><span class="hljs-punctuation">,</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span>)<span class="hljs-comment">; // 5</span><br></code></pre></td></tr></table></figure><p>对普通函数调用，我们通常把this绑定为null。</p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p><p>map() 方法按照原始数组元素顺序依次处理元素。</p><p>注意： map() 不会对空数组进行检测。</p><p>注意： map() 不会改变原始数组。</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p><p>reduce() 可以作为一个高阶函数，用于函数的 compose。</p><p>注意: reduce() 对于空数组是不会执行回调函数的。</p><pre><code>var numbers = [65, 44, 12, 4];function getSum(total, num) &#123;      return total + num;      &#125;</code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。<br>把一个Array中的空字符串删掉，可以这么写： </p><pre><code>var arr = [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, null, undefined, &#39;C&#39;, &#39;  &#39;];var r = arr.filter(function (s) &#123;    return s &amp;&amp; s.trim(); // 注意：IE9以下的版本没有trim()方法    &#125;);    r; // [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></pre><p>filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：</p><pre><code>var arr = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];var r = arr.filter(function (element, index, self) &#123;console.log(element); // 依次打印&#39;A&#39;, &#39;B&#39;, &#39;C&#39;console.log(index); // 依次打印0, 1, 2console.log(self); // self就是变量arrreturn true;&#125;);</code></pre><p>filter去重：</p><pre><code>r = arr.filter(function (element, index, self) &#123;return self.indexOf(element) === index;&#125;);</code></pre><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort() 方法用于对数组的元素进行排序<br>自定义sort方法进行排序：</p><pre><code>var arr = [&#39;Google&#39;, &#39;apple&#39;, &#39;Microsoft&#39;];arr.sort(function (s1, s2) &#123;x1 = s1.toUpperCase();x2 = s2.toUpperCase();if (x1 &lt; x2) &#123;    return -1;&#125;if (x1 &gt; x2) &#123;    return 1;&#125;return 0;&#125;); // [&#39;apple&#39;, &#39;Google&#39;, &#39;Microsoft&#39;]</code></pre><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="every"><a href="#every" class="headerlink" title="every"></a>every</h4><p>every()方法可以判断数组的所有元素是否满足测试条件。<br>例如，给定一个包含若干字符串的数组，判断所有字符串是否满足指定的测试条件：  </p><pre><code>var arr = [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];console.log(arr.find(function (s) &#123;return s.toLowerCase() === s;&#125;)); // &#39;pear&#39;, 因为pear全部是小写console.log(arr.find(function (s) &#123;return s.toUpperCase() === s;&#125;)); // undefined, 因为没有全部是大写的元素</code></pre><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>find()方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined：</p><pre><code>var arr = [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];console.log(arr.find(function (s) &#123;return s.toLowerCase() === s;&#125;)); // &#39;pear&#39;, 因为pear全部是小写console.log(arr.find(function (s) &#123;return s.toUpperCase() === s;&#125;)); // undefined, 因为没有全部是大写的元素</code></pre><h4 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h4><p>findIndex()和find()类似，也是查找符合条件的第一个元素，不同之处在于findIndex()会返回这个元素的索引，如果没有找到，返回-1：</p><pre><code>var arr = [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];console.log(arr.findIndex(function (s) &#123;return s.toLowerCase() === s;&#125;)); // 1, 因为&#39;pear&#39;的索引是1console.log(arr.findIndex(function (s) &#123;return s.toUpperCase() === s;&#125;)); // -1</code></pre><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>forEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。forEach()常用于遍历数组，因此，传入的函数不需要返回值</p><pre><code>var arr = [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];arr.forEach(s =&gt; console.log(s.toLowerCase())); // 依次打印每个元素arr.forEach(s =&gt; console.log(s.toLowerCase())); // 依次打印每个元素小写</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p><p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。<br>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p><p>怎么来理解这句话呢？请看下面的代码。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;<br><br>　　　　<span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>;<br><br>　　　　nAdd=<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;n+=<span class="hljs-number">1</span>&#125;<br><br>　　　　<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>&#123;<br>　　　　　　alert(n);<br>　　　　&#125;<br><br>　　　　<span class="hljs-keyword">return</span> f2;<br><br>　　&#125;<br><br>　　<span class="hljs-keyword">var</span> result=f1();<br><br>　　result(); <span class="hljs-comment">// 999</span><br><br>　　nAdd();<br><br>　　result(); <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p><p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><p>这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p><p>当然不是！闭包有非常强大的功能。举个栗子：</p><p>在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。</p><p>在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：</p><pre><code>function create_counter(initial) &#123;var x = initial || 0;return &#123;    inc: function () &#123;        x += 1;        return x;    &#125;&#125;&#125;var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2c1.inc(); // 3var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12c2.inc(); // 13</code></pre><p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</p><p>闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用Math.pow(x, y)函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数pow2和pow3：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make_pow</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(x, n);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 创建两个新函数:</span><br><span class="hljs-keyword">var</span> pow2 = make_pow(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">var</span> pow3 = make_pow(<span class="hljs-number">3</span>);<br><br><span class="hljs-built_in">console</span>.log(pow2(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 25</span><br><span class="hljs-built_in">console</span>.log(pow3(<span class="hljs-number">7</span>)); <span class="hljs-comment">// 343</span><br></code></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">x</span> =&gt; &#123;<br>    <span class="hljs-meta">if</span> (<span class="hljs-meta">x</span> &gt; 0) &#123;<br>        <span class="hljs-meta">return</span> <span class="hljs-meta">x</span> <span class="hljs-comment">* x;</span><br>    &#125;<br>    <span class="hljs-meta">else</span> &#123;<br>        <span class="hljs-meta">return</span> - <span class="hljs-meta">x</span> <span class="hljs-comment">* x;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果参数不是一个，就需要用括号()括起来：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 两个参数:<br><span class="hljs-function"><span class="hljs-params">(x, y)</span> =&gt;</span> x * x + y * y<br><br><span class="hljs-regexp">//</span> 无参数:<br><span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-number">3.14</span><br><br>// 可变参数:<br><span class="hljs-function"><span class="hljs-params">(x, y, ...rest)</span> =&gt;</span> &#123;<br>    var i, sum = x + y;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;rest.length; i++) &#123;<br>        sum += rest[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>与this的区别<br>箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。</p><p>回顾前面的例子，由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">this</span>.birth; <span class="hljs-comment">// 1990</span><br>        <span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear() - <span class="hljs-built_in">this</span>.birth; <span class="hljs-comment">// this指向window或undefined</span><br>        &#125;;<br>        <span class="hljs-keyword">return</span> fn();<br>    &#125;<br></code></pre></td></tr></table></figure><p>现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">var</span> obj = &#123;<br>    birth: <span class="hljs-number">1990</span>,<br>    getAge: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> b = this.birth; <span class="hljs-comment">// 1990</span><br>        <span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> = (<span class="hljs-params"></span>) =&gt;</span> <span class="hljs-keyword">new</span> Date().getFullYear() - this.birth; <span class="hljs-comment">// this指 向obj对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params"></span>)</span>;<br>    &#125;<br>&#125;;<br>obj.getAge(); <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><h3 id="generator-理解尚不到位，有空回来再补"><a href="#generator-理解尚不到位，有空回来再补" class="headerlink" title="generator(理解尚不到位，有空回来再补)"></a>generator(理解尚不到位，有空回来再补)</h3><p>generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。  </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>廖雪峰</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣217 存在重复元素</title>
    <link href="/2020/12/13/%E5%8A%9B%E6%89%A3217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/2020/12/13/%E5%8A%9B%E6%89%A3217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p><p> </p><p>示例 1:</p><p>输入: [1,2,3,1]<br>输出: true<br>示例 2:</p><p>输入: [1,2,3,4]<br>输出: false<br>示例 3:</p><p>输入: [1,1,1,3,3,4,3,2,4,2]<br>输出: true</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/contains-duplicate">https://leetcode-cn.com/problems/contains-duplicate</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>今天题目特别简单用一个set比较长度就可以了，可以复习一下set和哈希的知识(还有昨天的动态规划和贪心那道题，今天考六级没好好看┭┮﹏┭┮)</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * set方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> containsDuplicate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(nums);<br>    <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.size==nums.length)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> containsDuplicate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> nums) &#123;<br>        <span class="hljs-keyword">if</span> (set.has(x)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        set.add(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/contains-duplicate/solution/cun-zai-zhong-fu-yuan-su-by-leetcode-sol-iedd/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="复习内容"><a href="#复习内容" class="headerlink" title="复习内容"></a>复习内容</h2><h3 id="Set创建"><a href="#Set创建" class="headerlink" title="Set创建"></a>Set创建</h3><p>set 本身是一个构造函数，调用构造函数用来生成 Set 数据结构。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关键词　　标识符　= new Set();<br>例 　　let　　　　i　　 = new Set();<br>Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来进行数据初始化。<br>let i = new Set([1, 2, 3, 4, 4]);<br>会得到set{1, 2, 3, 4,}<br>注：如果初始化时给的值有重复的，会自动去除。</p><h3 id="Set的属性"><a href="#Set的属性" class="headerlink" title="Set的属性"></a>Set的属性</h3><p>Set 实例的方法分为两大类：操作方法（用于数据操作）和遍历方法（用于遍历数据）。<br>操作方法:<br>add(value)添加数据，并返回新的 Set 结构<br>delete(value)删除数据，返回一个布尔值，表示是否删除成功<br>has(value)查看是否存在某个数据，返回一个布尔值<br>clear()清除所有数据，没有返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-comment">// 添加数据 5</span><br><span class="hljs-keyword">let</span> addSet = set.add(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">console</span>.log(addSet); <span class="hljs-comment">// Set(5) &#123;1, 2, 3, 4, 5&#125;</span><br><span class="hljs-comment">// 删除数据 4s</span><br><span class="hljs-keyword">let</span> delSet = set.delete(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">console</span>.log(delSet); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 查看是否存在数据 4</span><br><span class="hljs-keyword">let</span> hasSet = set.has(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">console</span>.log(hasSet); <span class="hljs-comment">// false</span><br><span class="hljs-comment">// 清除所有数据</span><br>set.clear();<br><span class="hljs-built_in">console</span>.log(set); <span class="hljs-comment">// Set(0) &#123;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="Set遍历方法"><a href="#Set遍历方法" class="headerlink" title="Set遍历方法"></a>Set遍历方法</h3><p>Set 提供了三个遍历器生成函数和一个遍历方法。<br>keys()　　　　 返回一个键名的遍历器<br>values()　　　  返回一个键值的遍历器<br>entries()　　　  返回一个键值对的遍历器<br>orEach()　　　使用回调函数遍历每个成员  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> color = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>]);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> color.keys())&#123;<br> <span class="hljs-built_in">console</span>.log(item);<br>&#125;<br><span class="hljs-comment">// red</span><br><span class="hljs-comment">// green</span><br><span class="hljs-comment">// blue</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> color.values())&#123;<br> <span class="hljs-built_in">console</span>.log(item);<br>&#125;<br><span class="hljs-comment">// red</span><br><span class="hljs-comment">// green</span><br><span class="hljs-comment">// blue</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> color.entries())&#123;<br> <span class="hljs-built_in">console</span>.log(item);<br>&#125;<br><span class="hljs-comment">// [&quot;red&quot;, &quot;red&quot;]</span><br><span class="hljs-comment">// [&quot;green&quot;, &quot;green&quot;]</span><br><span class="hljs-comment">// [&quot;blue&quot;, &quot;blue&quot;]</span><br>color.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br> <span class="hljs-built_in">console</span>.log(item)<br>&#125;)<br><span class="hljs-comment">// red</span><br><span class="hljs-comment">// green</span><br><span class="hljs-comment">// blue</span><br></code></pre></td></tr></table></figure><h3 id="与数组相关操作"><a href="#与数组相关操作" class="headerlink" title="与数组相关操作"></a>与数组相关操作</h3><p>由于扩展运算符…，内部的原理也是使用的 for-of 循环，所以也可以用于操作 Set 结构。<br>例如将 Set 结构转换为数组结构：</p><pre><code>let color = new Set([&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]);let colorArr = [...color];</code></pre><h3 id="利用Set实现交并集等"><a href="#利用Set实现交并集等" class="headerlink" title="利用Set实现交并集等"></a>利用Set实现交并集等</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-keyword">let</span> num2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br><br><span class="hljs-comment">//并集</span><br><span class="hljs-keyword">let</span> union = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...num1,...num2]);<br><span class="hljs-built_in">console</span>.log(union);<span class="hljs-comment">//Set &#123; 1, 2, 3, 4, 5, 6 &#125;</span><br><br><span class="hljs-comment">//交集</span><br><span class="hljs-keyword">let</span> intersect = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<br>    [...num1].filter(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span> num2.has(x))<br>)<br><span class="hljs-built_in">console</span>.log(intersect); <span class="hljs-comment">//Set &#123; 3, 4 &#125;</span><br><br><span class="hljs-comment">//差集</span><br><span class="hljs-keyword">let</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<br>    [...num1].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !num2.has(x))<br>)<br><span class="hljs-built_in">console</span>.log(difference); <span class="hljs-comment">//Set &#123; 1, 2 &#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Set</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣376 摆动序列</title>
    <link href="/2020/12/12/%E5%8A%9B%E6%89%A3376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
    <url>/2020/12/12/%E5%8A%9B%E6%89%A3376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>示例 1:</p><p>输入: [1,7,4,9,2,5]<br>输出: 6<br>解释: 整个序列均为摆动序列。<br>示例 2:</p><p>输入: [1,17,5,10,13,15,10,5,16,8]<br>输出: 7<br>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。<br>示例 3:</p><p>输入: [1,2,3,4,5,6,7,8,9]<br>输出: 2<br>进阶:<br>你能否用 O(n) 时间复杂度完成此题?</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/wiggle-subsequence">https://leetcode-cn.com/problems/wiggle-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题我的第一思路是考虑(nums[i]-nums[i-1])*(nums[i+1]-nums[i])的正负，但是要考虑很多特殊情况，如数组为空，数组长度为1，传入值为相差的情况，这种情况处理过程中感觉特别困难（一开始想的是从1开始遍历len初值为2然后每成功一次len++，后面发现[0,0]不好处理,用数组长度作为len初始值不符合就–也不太好，主要是两数相等只能len为1且两个数时没法进行遍历因为遍历长度为2-1,最后从0开始遍历初始len为0，如果nums[i]和nums[i+1]相等删除nums[i+1]，然后再进行判断，如果i为0直接长度加1，否则进行上式判断，可惜最后还是报错想了想是因为一个个判断可能不是最优解，直接看题解了今天算没做出来吧，也贴一下自己的题解看看以后能不能改动，发现还有官方题解这种东西）</p><p>2020.12.14更新：之前的思路有点问题是因为并不能直接删除不符合题目的，如1 2 3 2，如果把3删除2也不符题意，而如果取3则能多1长度，故删除不为最优解，最优解不用删除元素，把else {  nums.splice(i + 1, 1);      i–;      }删除即可，意为取转折点长度加一即可如1 2 长度此时为2，3长度不变，此时就可以正常判断峰点，为最优点<br>同时分享来自mantoufan大大的题解，代码简洁且思路多样，以后像他多加学习！</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**自己的题解，错误  正确答案把</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> wiggleMaxLength = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> nums.length;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> len = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;<br>                nums.splice(i + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>                i--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                    len++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (((nums[i] - nums[i - <span class="hljs-number">1</span>]) * (nums[i + <span class="hljs-number">1</span>] - nums[i])) &lt; <span class="hljs-number">0</span>) &#123;<br>                    len++;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    nums.splice(i + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>                    i--;<br>                &#125;<br>            &#125;<br>        &#125;<br>                    <span class="hljs-keyword">return</span> len;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>动态规划：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> wiggleMaxLength = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> up = down = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>            up = <span class="hljs-built_in">Math</span>.max(up, down + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i - <span class="hljs-number">1</span>]) &#123;<br>            down = <span class="hljs-built_in">Math</span>.max(up + <span class="hljs-number">1</span>, down);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(up, down);<br>&#125;;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><p>贪心算法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript">观察这个序列可以发现，我们不断地交错选择「峰」与「谷」，可以使得该序列尽可能长。证明非常简单：如果我们选择了一个「过渡元素」，那么在原序列中，这个「过渡元素」的两侧有一个「峰」和一个「谷」。不失一般性，我们假设在原序列中的出现顺序为「峰」「过渡元素」「谷」。如果「过渡元素」在选择的序列中小于其两侧的元素，那么「谷」一定没有在选择的序列中出现，我们可以将「过渡元素」替换成「谷」；同理，如果「过渡元素」在选择的序列中大于其两侧的元素，那么「峰」一定没有在选择的序列中出现，我们可以将「过渡元素」替换成「峰」。这样一来，我们总可以将任意满足要求的序列中的所有「过渡元素」替换成「峰」或「谷」。并且由于我们不断地交错选择「峰」与「谷」的方法就可以满足要求，因此这种选择方法就一定可以达到可选元素数量的最大值。<br><br>这样，我们只需要统计该序列中「峰」与「谷」的数量即可（注意序列两端的数也是「峰」或「谷」），但需要注意处理相邻的相同元素。<br><br>在实际代码中，我们记录当前序列的上升下降趋势。每次加入一个新元素时，用新的上升下降趋势与之前对比，如果出现了「峰」或「谷」，答案加一，并更新当前序列的上升下降趋势。<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br><span class="hljs-keyword">var</span> wiggleMaxLength = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-keyword">let</span> prevdiff = nums[<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> ret = prevdiff !== <span class="hljs-number">0</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">const</span> diff = nums[i] - nums[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> ((diff &gt; <span class="hljs-number">0</span> &amp;&amp; prevdiff &lt;= <span class="hljs-number">0</span>) || (diff &lt; <span class="hljs-number">0</span> &amp;&amp; prevdiff &gt;= <span class="hljs-number">0</span>)) &#123;<br>            ret++;<br>            prevdiff = diff;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;;<br><br>作者：LeetCode-Solution<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> wiggleMaxLength = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, len = <span class="hljs-number">1</span>, trend</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> nums.length &lt; <span class="hljs-number">2</span> ? nums.length :<br>            (nums.reduce(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> (<br>                prev !== cur &amp;&amp; prev &gt; cur !== trend &amp;&amp; (len++, trend = prev &gt; cur), cur<br>            )), len)<br>&#125;;<br><br>作者：mantoufan<br>链接：https:<span class="hljs-comment">//leetcode-cn.com/problems/wiggle-subsequence/solution/dong-tai-gui-hua-tan-xin-suan-fa-1xing-d-ig8l/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣649 Dota2 参议院</title>
    <link href="/2020/12/11/%E5%8A%9B%E6%89%A3649-Dota2-%E5%8F%82%E8%AE%AE%E9%99%A2/"/>
    <url>/2020/12/11/%E5%8A%9B%E6%89%A3649-Dota2-%E5%8F%82%E8%AE%AE%E9%99%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：</p><p>禁止一名参议员的权利：</p><p>参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</p><p>宣布胜利：</p><p>          如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</p><p> </p><p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p><p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。</p><p> </p><p>示例 1：</p><p>输入：”RD”<br>输出：”Radiant”<br>解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人<br>示例 2：</p><p>输入：”RDD”<br>输出：”Dire”<br>解释：<br>第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利<br>第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止<br>第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利<br>因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利 </p><p>提示：</p><p>给定字符串的长度在 [1, 10,000] 之间. </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/dota2-senate">https://leetcode-cn.com/problems/dota2-senate</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把这个字符串变成数组,然后从i=0开始遍历如果a[i]是D就把i+1到末尾遍历找到下一个R把它变为0，如果后面没找到就从头找到i-1,如果都没法找到说明都是队友了就赢了,反之亦然(这题浪费最多的时间就在如果发现为’0’则continue而非break，找了几小时的错结果是这里，感谢小群同学的纠错)</p><p>一、JS字符串内容不可以通过下标直接改动，可以转化为数组，或自定义函数进行修改</p><p>1、常用 str.split(‘’);</p><p>2、用一种es6的新方法：Object.values(str);</p><p>3、还有一种：Array.from(str);</p><p>二丶自定义函数</p><p>1、</p><pre><code>const replaceStr1 = (str, index, char) =&gt; &#123;  const strAry = str.split(&#39;&#39;);  strAry[index] = char;  return strAry.join(&#39;&#39;);  &#125;  replaceStr1(str1, 4, &#39;-&#39;); // =&gt; Good-Morning  replaceStr1(str2, 4, &#39;-&#39;); // =&gt; Hell- World</code></pre><p>2、</p><pre><code>const replaceStr2 = (str, index, char) =&gt; &#123;  return str.substring(0, index) + char + str.substring(index + 1);&#125;  replaceStr2(str1, 4, &#39;-&#39;); // =&gt; Good-Morning  replaceStr2(str2, 4, &#39;-&#39;); // =&gt; Hell- World</code></pre><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">senate</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">var</span> predictPartyVictory = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">senate</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a = senate.split(<span class="hljs-string">&#x27;&#x27;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-string">&#x27;R&#x27;</span>) &#123;<br>                <span class="hljs-keyword">let</span> ifchange = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (i != a.length - <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; a.length; j++) &#123;<br>                        <span class="hljs-keyword">if</span> (a[j] == <span class="hljs-string">&#x27;D&#x27;</span>) &#123;<br>                            a[j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                            ifchange = <span class="hljs-literal">true</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!ifchange &amp;&amp; i) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; i; k++) &#123;<br>                        <span class="hljs-keyword">if</span> (a[k] == <span class="hljs-string">&#x27;D&#x27;</span>) &#123;<br>                            a[k] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                            ifchange = <span class="hljs-literal">true</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!ifchange) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Radiant&quot;</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-string">&#x27;D&#x27;</span>) &#123;<br>                <span class="hljs-keyword">let</span> ifchange = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (i != a.length - <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; a.length; j++) &#123;<br>                        <span class="hljs-keyword">if</span> (a[j] == <span class="hljs-string">&#x27;R&#x27;</span>) &#123;<br>                            a[j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                            ifchange = <span class="hljs-literal">true</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!ifchange &amp;&amp; i) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; i; k++) &#123;<br>                        <span class="hljs-keyword">if</span> (a[k] == <span class="hljs-string">&#x27;R&#x27;</span>) &#123;<br>                            a[k] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                            ifchange = <span class="hljs-literal">true</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!ifchange) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dire&quot;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>来自博主草莓糖&amp;薄荷茶的题解(<a href="https://www.cnblogs.com/beheTea/p/14119337.html)%E4%BB%A3%E7%A0%81%E4%BC%9A%E6%9B%B4%E7%AE%80%E6%B4%81">https://www.cnblogs.com/beheTea/p/14119337.html)代码会更简洁</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Radiant = [];      <span class="hljs-keyword">var</span> Dire = [];     <span class="hljs-keyword">var</span> Senate = <span class="hljs-built_in">Array</span>.from(senate);<br><span class="hljs-keyword">var</span> SenanteL = Senate.length; <span class="hljs-comment">//数组长度</span><br>      <span class="hljs-comment">//循环数组，找到R和D，并分别将他们push到相对应的数组中去</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; SenanteL; i++) &#123;<br>        <span class="hljs-keyword">if</span> (Senate[i] == <span class="hljs-string">&quot;R&quot;</span>) &#123;<br>          Radiant.push(i);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          Dire.push(i);<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">while</span> (Radiant.length &gt; <span class="hljs-number">0</span> &amp;&amp; Dire.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//Radiant和Dire两个数组中分别存的是R和D在初始数组中的索引</span><br>        <span class="hljs-comment">//比较两个数组首元素大小，数值小的说明其在初始数组中位于另一个的前面，那么，他就可以行使权力使对手无法发动技能</span><br>        <span class="hljs-comment">//通俗的讲，谁数值小，谁先动手，另一个数值大的只能被干掉</span><br>        <span class="hljs-keyword">if</span> (Radiant[<span class="hljs-number">0</span>] &lt; Dire[<span class="hljs-number">0</span>]) &#123;<br>          Radiant.push(Radiant[<span class="hljs-number">0</span>] + SenanteL);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          Dire.push(Dire[<span class="hljs-number">0</span>] + SenanteL);<br>        &#125;<br>        <span class="hljs-comment">//shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值</span><br>　　　　 <span class="hljs-comment">//使用这个方法，当前轮次结束之后，数组中的元素就是本轮存活下来（有发言权）的人</span><br><br>        Radiant.shift();<br>        Dire.shift();<br>      &#125;<br>      <span class="hljs-keyword">return</span> Radiant.length &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;Radiant&quot;</span> : <span class="hljs-string">&quot;Dire&quot;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣860 柠檬水找零</title>
    <link href="/2020/12/10/%E5%8A%9B%E6%89%A3680-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
    <url>/2020/12/10/%E5%8A%9B%E6%89%A3680-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><p>示例 1：</p><p>输入：[5,5,5,10,20]<br>输出：true<br>解释：<br>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。<br>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。<br>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。<br>示例 2：</p><p>输入：[5,5,10]<br>输出：true<br>示例 3：</p><p>输入：[10,10]<br>输出：false<br>示例 4：</p><p>输入：[5,5,10,10,20]<br>输出：false<br>解释：<br>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。<br>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。<br>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。 </p><p>提示：</p><p>0 &lt;= bills.length &lt;= 10000<br>bills[i] 不是 5 就是 10 或是 20 </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lemonade-change">https://leetcode-cn.com/problems/lemonade-change</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题很简单，注意读题逻辑即可。一开始做的时候以为可以先欠着，而实际上每次找零都要进行判断，设置标记flag不符条件将其改为0即可（今天第一天刷力扣，尽量每天都能打卡，实在忙两天一题）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> lemonadeChange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">bills</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> fivenum = <span class="hljs-number">0</span>, tennum = <span class="hljs-number">0</span>, twenum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> bills) &#123;<br>        <span class="hljs-keyword">if</span> (bills[item] == <span class="hljs-number">5</span>) &#123;<br>            fivenum++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bills[item] == <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!fivenum) &#123;<br>                flag = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                fivenum--;<br>                tennum++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (tennum &amp;&amp; fivenum) &#123;<br>                tennum--;<br>                fivenum--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fivenum &gt;= <span class="hljs-number">3</span>) &#123;<br>                fivenum -= <span class="hljs-number">3</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                flag = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>力扣</category>
      
    </categories>
    
    
    <tags>
      
      <tag>顺序逻辑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云签到搭建</title>
    <link href="/2020/11/11/%E4%BA%91%E7%AD%BE%E5%88%B0%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/11/11/%E4%BA%91%E7%AD%BE%E5%88%B0%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>获取云服务器<br>可以从我的上一个博客（点击查看）获取教程，本篇使用的是宝塔面板（centos7.7），但即使不用宝塔面板搭建也大同小异。</p><p>准备<br>自己配置好LNMP环境。<br>选择的项目是GitHub上的一个开源项目，地址：<a href="https://github.com/MoeNetwork/Tieba-Cloud-Sign">https://github.com/MoeNetwork/Tieba-Cloud-Sign</a><br>建议先自行查看下该项目的README。<br>配置完的最终效果如图：<br>在这里插入图片描述</p><p>配置<br>1.安装docker管理器<br>2.安装docker-compose<br>先安装pip工具，这里安装pip3：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yum</span> install python<span class="hljs-number">3</span>-pip<br></code></pre></td></tr></table></figure><p>再用pip3安装docker-compose：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip3 <span class="hljs-keyword">install</span> docker-compose <br></code></pre></td></tr></table></figure><p>等待安装完成</p><p>3.检查<br>检查安装是否成功</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker -v</span><br><span class="hljs-attribute">docker-compose -v</span><br></code></pre></td></tr></table></figure><p>部署<br>1.下载docker-compose.yml</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">    wget https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/zsnmwy/</span>Tieba-Cloud-Sign<span class="hljs-regexp">/master/</span>docker-compose.yml<br><span class="hljs-regexp">//</span>注：如提示连接失败，尝试用别的SSH<br></code></pre></td></tr></table></figure><p>2.编辑yml文件<br>在根目录找到docker-compose.yml（善用搜索），编辑它，将端口改为除80以外的未占用的端口，并将true改为false</p><p>3.运行命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose up -d</span><br></code></pre></td></tr></table></figure><p>等待部署完毕。</p><p>安装程序<br>输入ip+端口号，进入如下页面：<br>点击安装<br>选择“不”<br>选择“是”，并填写信息</p><p>完成安装<br>可以直接绑定账号使用了<br>有问题欢迎讨论</p><p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://blog.csdn.net/weixin_45635130/article/details/105950047">https://blog.csdn.net/weixin_45635130/article/details/105950047</a></p>]]></content>
    
    
    <categories>
      
      <category>网站搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云签到</tag>
      
      <tag>搭建</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>晚安</title>
    <link href="/2020/11/10/%E6%99%9A%E5%AE%89/"/>
    <url>/2020/11/10/%E6%99%9A%E5%AE%89/</url>
    
    <content type="html"><![CDATA[<p>have a good night</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2020/11/10/%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/11/10/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>测试</p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
      <category>测试中的测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
